diff --git a/aaaaaaaaa.txt b/aaaaaaaaa.txt
deleted file mode 100644
index 9853b6c..0000000
--- a/aaaaaaaaa.txt
+++ /dev/null
@@ -1,161 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['point0']
-objects after appending new_object: ['point0']
-global_objects after appending new_object: ['point0']
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mypoint']
-global_objects at the start: ['mypoint']
-objects after creation of new_object : ['mypoint']
-gregregregrr
-global_objects at the start: ['mypoint', 'circle0']
-objects after appending new_object: ['mypoint', 'circle0']
-global_objects after appending new_object: ['mypoint', 'circle0']
-[92mCreated new object.[0m
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-self.yc : yc0
-result: None
-Command string: mycircle.xc = 10
-thing
-==================================================================================
-Setting property : xc
-On object: mycircle
-selected_property: xc
-value: 10
-self.yc : yc0
-result: None
-Command string: mycircle.yc = 0
-thing
-==================================================================================
-Setting property : yc
-On object: mycircle
-selected_property: yc
-value: 0
-self.yc : yc0
-result: None
-Command string: mycircle.r = 3
-thing
-==================================================================================
-Setting property : r
-On object: mycircle
-selected_property: r
-value: 3
-self.yc : 0
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-name_str: mycircle
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-obj.name == mypoint
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: <__main__.circle object at 0x7f04b3fc1130>
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : <__main__.circle object at 0x7f04b3fc1130>
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-Circle equation bullshit: 
-((x)-(10))**2+((y)-(0))**2=(3)**2
-oof
-oof22
-bullshit
-equation : Eq(x, 7.0)
-"x"+str(object1.var_count) == x0
-equation : Eq(y, 2.0)
-"x"+str(object1.var_count) == x0
-substituted_equations
-Eq(tempvarx, 7.0)
-Eq(tempvary, 2.0)
-Eq(tempvary**2 + (tempvarx - 10)**2, 9)
-
-result: []
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [][0m
-[94m>>> [0m
\ No newline at end of file
diff --git a/abc.txt b/abc.txt
deleted file mode 100644
index ce6a359..0000000
--- a/abc.txt
+++ /dev/null
@@ -1,6 +0,0 @@
--(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
--(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-
--(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-
--(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
diff --git a/anothebullshitbackupthing.py b/anothebullshitbackupthing.py
deleted file mode 100644
index 2202156..0000000
--- a/anothebullshitbackupthing.py
+++ /dev/null
@@ -1,1913 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-
-
-
-
-'''
-
-
-Todo list:
-
-- Add a polygon object or atleast a triangle.
-- Way to compute angles and add an angle object. (Basically use stuff like the law of sines to compute them etc etc.)
-- 3D-objects.
-- Add a line to a point which has a certain angle.
-- Default arguments. (if an argument is not given to a function then it assumes that a certain argument has a certain value instead of erroring out.)
-
-'''
-
-
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-class triangle:
-	def __init__(self, *arguments):
-
-
-		self.debug = False
-		
-		# {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.default_arguments = {"x0":0, "y0":0, "x1":0, "y1":0, "x2":0, "y2":0} # list of tuples which are all 0,0
-
-		self.parameters = ["x0", "y0", "x1", "y1", "x2", "y2"]
-		
-		self.method_strings = ["set_lines_from_points"]
-		self.methods = [set_lines_from_points]
-
-		self.num_args = [3]
-		self.method_arg_types = [["point", "point", "point"]]
-
-		common_arg_stuff(self, *arguments)
-
-
-		'''
-				self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def get_range(self,x0,y0,x1,y1):
-
-		# spaghetti code
-
-		# get the range of numbers:
-		
-		output = []
-
-		if x0 > x1:
-			output.append("x>="+str(x1))
-			output.append("x<="+str(x0))
-		else:
-			output.append("x<="+str(x1))
-			output.append("x>="+str(x0))
-
-		if y0 > y1:
-			output.append("y>="+str(y1))
-			output.append("y<="+str(y0))
-		else:
-			output.append("y<="+str(y1))
-			output.append("y>="+str(y0))
-
-		return output
-
-
-
-
-	def get_line_equation(self,x0,y0,x1,y1):
-
-		# a,b = [[(y0-y1)/(x0*y1-x1*y0),(-x0+x1)/(x0*y1-x1*y0)]]   and c=1
-		a = simplify("(({})-({}))/(({}*{})-({}*{}))".format(str(y0), str(y1), str(x0), str(y1), str(x1), str(y0)))
-		b = simplify("(-({})+({}))/(({}*{})-({}*{}))".format(str(x0), str(x1), str(x0), str(y1), str(x1), str(y0)))
-		c = "1"
-		return "({})*x+({})*y+1=0".format(str(a), str(b))
-
-
-
-	def get_equations(self):
-
-		# basically just return the list of lines, except that there are constrictions on the answers
-
-		line_equations = [get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x2, self.y2)]
-
-		constraints = []
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x1, self.y1)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x2, self.y2)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x3, self.y3)
-
-		final_eqs = []
-
-		for i in range(3):
-
-			equation = line_equations[i]
-			constraint_thing = constraints[i]
-
-			final_equation = equation + constraint_thing
-
-			final_eqs.append([final_equation])
-
-		return final_eqs
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	def set_lines_from_points(self, point1, point2, point3):
-
-		self.x0 = point1.x
-		self.y0 = point1.y
-
-		self.x1 = point2.x
-		self.y1 = point2.y
-
-		self.x2 = point3.x
-		self.y2 = point3.y
-
-
-
-
-
-'''
-
- - Polygon which has X points.
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-'''
-# def mindistobjdot(command:str, objects:list):
-
-
-def polygon_command(command_string: str, objects: list):
-
-	# basically three lines.
-
-	# one point is line1 int line2  second point is line2 int line3  and third is line3 int line1
-
-	arguments = command_string.split(" ")
-
-	lines = arguments[1:]
-
-	line_objects = []
-
-	for line in lines:
-
-		line_objects.append(get_object_by_name(line))
-
-
-
-
-
-	
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	#x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	#y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	#x_is_var = False
-
-	#solutions = sympy.solve(object_equations,"x,y")
-	sol_x = sympy.solve(object_equations,"x")
-	sol_y = sympy.solve(object_equations,"y")
-
-
-	print("sol_x : "+str(sol_x))
-	print("sol_y : "+str(sol_y))
-	if isinstance(sol_x, list):
-		sol_x = sol_x[0]
-		sol_y = sol_y[0]
-
-
-	thing = sol_x
-	substitution = thing.update(sol_y)
-	print("substitution: "+str(substitution))
-	print("thing: "+str(thing))
-
-	#print("Solutions: "+str(solutions))
-
-
-
-	#y0 = y0[list(y0.keys())[0]]
-
-	x = Symbol('x')
-	y = Symbol('x')
-	distance_function = distance_thing(x,y,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-	distance_function = distance_function.subs(thing)
-	print("Substituted distance function: "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	
-	print("f: "+str(f))
-	if not maximumthing:
-
-		solution = minimum(f, x)
-	else:
-		solution = maximum(f, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/anotherbackup.py b/anotherbackup.py
deleted file mode 100644
index 6ea287c..0000000
--- a/anotherbackup.py
+++ /dev/null
@@ -1,843 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects"]
-
-
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-	def __init__(self, x=None, y=None, vector=None):
-		if vector != None:
-			self.vector = vector
-			self.x=vector.item(0)
-			self.y=vector.item(1)
-		elif x==None and y==None:
-			warn("Warning. Uninitialized point.")
-			return
-		else:
-			self.vector = np.array([[x],[y]])
-			self.x = x
-			self.y = y
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	
-		
-
-def get_object_by_name(name_str):
-
-	count = 0
-	obj = global_objects[0]
-	while obj.name != name_str and count != len(global_objects):
-		obj = global_objects[count]
-		count += 1
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(point1, point2):
-
-		# get vector from point1 to point2
-
-		from1to2 = -1*point1+point2
-
-		self.set_values_point_line(point1, from1to2)
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(method_string, command):
-		# global_objects
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-
-	for equation1, equation2 in zip(equations1, equations2):
-
-
-
-
-		temp_var_x = Symbol("tempvarx")
-		temp_var_y = Symbol("tempvary")
-
-		substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-		substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-		print("substitute_first : " + str(substitute_first))
-
-		equation1 = equation1.subs(substitute_first)
-
-		equation2 = equation2.subs(substitute_second)
-
-		print("-----------")
-		print(equation1)
-		print(equation2)
-		print("-----------")
-		print(temp_var_x)
-		print(temp_var_y)
-
-		result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-		print("result: "+str(result))
-		results.append(result)
-	return results
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-
-	print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	obj.run_method_on_self(method_str, command_string)
-	#function = getattr(obj, method_str, None)
-
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle"]
-	min_arg_lengths = [0,0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0,3]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-
-				if len(command_string.split(" ")) == 1:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/backups/ffoewjfeowfejw.py b/backups/ffoewjfeowfejw.py
deleted file mode 100644
index 9447dca..0000000
--- a/backups/ffoewjfeowfejw.py
+++ /dev/null
@@ -1,1260 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-
-
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print(string_oof_1)
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-
-		self.b = sympy.simplify(string_oof_2)
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	# now solve the differential equation to get min distance
-
-	#diff_eq = Eq(f(x).diff(x), 0)  # f'(x) = 0
-
-	#oof = sympy.Derivative(distance_function, 'x')
-	#print("oooff : "+str(oof))
-	#diff_eq = Eq(distance_function, 0)
-
-	'''
-	from sympy.calculus.util import *
-	f = (x**3 / 3) - (2 * x**2) - 3 * x + 1
-	ivl = Interval(0,3)
-	print(minimum(f, x, ivl))
-	print(maximum(f, x, ivl))
-	print(stationary_points(f, x, ivl))
-
-	'''
-
-
-	#derivative = distance_function.diff('x')
-	#equation = Eq(derivative, 0)
-	#solution = solve(equation) # solve the equation
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	#solution.append(y0.subs({'x':solution[0]}))
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/backups/geometrylib.py b/backups/geometrylib.py
deleted file mode 100644
index dcf69cb..0000000
--- a/backups/geometrylib.py
+++ /dev/null
@@ -1,1127 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print(string_oof_1)
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-
-		self.b = sympy.simplify(string_oof_2)
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-	results = []
-	
-	temp_var_x = Symbol("tempvarx")
-	temp_var_y = Symbol("tempvary")
-
-	substituted_equations = []
-
-
-	
-	for equation in equations1:
-		substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-	for equation in equations2:
-
-		substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-	result = sympy.solve(substituted_equations, (temp_var_x, temp_var_y))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point"]
-	min_arg_lengths = [0,0,0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0,3,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/backupthing.py b/backupthing.py
deleted file mode 100644
index d7aeefb..0000000
--- a/backupthing.py
+++ /dev/null
@@ -1,220 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-
-
-global_things = []
-
-
-
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-
-class point:
-	def __init__(self, x=None, y=None, vector=None):
-		if vector != None:
-			self.vector = vector
-			self.x=vector.item(0)
-			self.y=vector.item(1)
-		elif x==None and y==None:
-			warn("Warning. Uninitialized point.")
-			return
-		else:
-			self.vector = np.array([[x],[y]])
-			self.x = x
-			self.y = y
-
-	
-		
-
-
-
-class line:
-	def __init__(self,a="unknown",b="unknown",c="unknown"):
-
-
-		# a*x+b*x=c
-		self.debug=False
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-
-		self.a = a
-		self.b = b
-		self.c = c
-
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		self.c_val = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(point1, point2):
-
-		# get vector from point1 to point2
-
-		from1to2 = -1*point1+point2
-
-		self.set_values_point_line(point1, from1to2)
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-
-	for equation1, equation2 in zip(equations1, equations2):
-		
-
-
-
-	temp_var_x = Symbol("tempvarx")
-	temp_var_y = Symbol("tempvary")
-
-	substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-	substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-	print("substitute_first : " + str(substitute_first))
-
-	equation1 = equation1.subs(substitute_first)
-
-	equation2 = equation2.subs(substitute_second)
-
-	print("-----------")
-	print(equation1)
-	print(equation2)
-	print("-----------")
-	print(temp_var_x)
-	print(temp_var_y)
-
-	result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equation()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	line_object2 = line(a=11, b=4, c=3)
-	intersection(line_object, line_object2)
-
-
-	return 0
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-
-	
-
-
-		
-
-
-
-
diff --git a/check_area_between_intersections.txt b/check_area_between_intersections.txt
deleted file mode 100644
index 3903991..0000000
--- a/check_area_between_intersections.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-
-line a=4 b=-2 c=3
-line0.name = myline
-area_between_intersections myline y=x**2-10*x+10
-quit
diff --git a/check_integral.txt b/check_integral.txt
deleted file mode 100644
index d41e5f0..0000000
--- a/check_integral.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-integrate y=x**2 x 1 3
-quit
diff --git a/check_line_intersect.txt b/check_line_intersect.txt
deleted file mode 100644
index b2fc6a9..0000000
--- a/check_line_intersect.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-line a=1 b=2 c=3
-line a=4 b=5 c=6
-intersect line0 line1
-quit
diff --git a/check_max_output_dot_line.txt b/check_max_output_dot_line.txt
deleted file mode 100644
index c86b50e..0000000
--- a/check_max_output_dot_line.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline
-point
-point0.name = mypoint
-mypoint.set_point_to_values 0 0
-maxdistobjdot myline mypoint
-quit
diff --git a/check_min_dist_point_line.txt b/check_min_dist_point_line.txt
deleted file mode 100644
index a8f32a4..0000000
--- a/check_min_dist_point_line.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline
-point
-point0.name = mypoint
-mypoint.set_point_to_values 0 0
-mindistpointobjdot myline mypoint
-quit
diff --git a/check_min_output_dot_line.txt b/check_min_output_dot_line.txt
deleted file mode 100644
index 6d9cf9f..0000000
--- a/check_min_output_dot_line.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline
-point
-point0.name = mypoint
-mypoint.set_point_to_values 0 0
-mindistobjdot myline mypoint
-quit
diff --git a/check_point_on_circle.txt b/check_point_on_circle.txt
deleted file mode 100644
index 10afb6e..0000000
--- a/check_point_on_circle.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-point
-point0.name = mypoint
-mypoint.set_point_to_values 7 2
-circle
-circle0.name = mycircle
-mycircle.xc = 10
-mycircle.yc = 2
-mycircle.r = 3
-intersect mypoint mycircle
diff --git a/check_var_assignment_to_function_result.txt b/check_var_assignment_to_function_result.txt
deleted file mode 100644
index 6a38550..0000000
--- a/check_var_assignment_to_function_result.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline1
-line a=4 b=5 c=6
-line0.name = myline2
-myvar := intersect myline1 myline2
-point [myvar]
-point0.name = mypoint
-mypoint
-quit
diff --git a/check_var_subsequences.txt b/check_var_subsequences.txt
deleted file mode 100644
index 1a621a2..0000000
--- a/check_var_subsequences.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline1
-line a=4 b=5 c=6
-line0.name = myline2
-myvar := intersect myline1 myline2
-point [myvar][0:1]
-point0.name = mypoint
-mypoint
-quit
diff --git a/circlething.txt b/circlething.txt
deleted file mode 100644
index 9f12f1f..0000000
--- a/circlething.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-
-circle xc=8 yc=3 r=3
-point x=0 y=0
-mindistobjdot circle0 point0
-
-line a=0 b=-1 c=0
-pointthing := intersect circle0 line0
-point [pointthing]
-point1.name = thingpoint
-mindistobjdot thingpoint point0
-quit
diff --git a/commands.txt b/commands.txt
deleted file mode 100644
index 08c438b..0000000
--- a/commands.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-line
-line0.name = myline1
-line
-line0.name = myline2
-myline1.a = 1
-myline1.b = 2
-myline1.c = 3
-myline2.a = 4
-myline2.b = 5
-myline2.c = 6
-intersect myline1 myline2
diff --git a/eeee.txt b/eeee.txt
deleted file mode 100644
index bdaa5b8..0000000
--- a/eeee.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file tests/check_area_between_intersections.txt.
-Command string: 
-Command string: line a=4 b=-2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=4', 'b=-2', 'c=3']
-object_name: line
-{'a': '4', 'b': '-2', 'c': '3'}
-*arguments_thing : {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: area_between_intersections myline y=x**2-10*x+10
-fewfeewfewfewf
-name_str: myline
-['myline']
----------------------------
-myline
----------------------------
-oof
-oof22
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]]
-[-3, 4*x - 2*y]
-[10, -x**2 + 10*x + y]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-intersection_points == [(6 - sqrt(110)/2, 27/2 - sqrt(110)), (sqrt(110)/2 + 6, sqrt(110) + 27/2)]
-thingoof intersection_x_values ==
-[4*x - 2*y + 0 + 3]
-[y]
-ok so it is a bare function and not a system of equations
-[-x**2 + 10*x + y - 10]
-[y]
-ok so it is a bare function and not a system of equations
-functions_in_y_format == [[2*x + 3/2], [x**2 - 10*x + 10]]
-bigger function: 2*x + 3/2
-smaller_fun : x**2 - 10*x + 10
-Difference function: -x**2 + 12*x - 17/2
-intersection_x_values[0] == 6 - sqrt(110)/2
-intersection_x_values[1] == sqrt(110)/2 + 6
-[33mArea: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2[0m
-Command result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git a/fewnjfnekgkrejkgrjknrek.py b/fewnjfnekgkrejkgrjknrek.py
deleted file mode 100644
index 89912c7..0000000
--- a/fewnjfnekgkrejkgrjknrek.py
+++ /dev/null
@@ -1,1641 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/fmgerlkgrenengrejgnerk.py b/fmgerlkgrenengrejgnerk.py
deleted file mode 100644
index 2202156..0000000
--- a/fmgerlkgrenengrejgnerk.py
+++ /dev/null
@@ -1,1913 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-
-
-
-
-'''
-
-
-Todo list:
-
-- Add a polygon object or atleast a triangle.
-- Way to compute angles and add an angle object. (Basically use stuff like the law of sines to compute them etc etc.)
-- 3D-objects.
-- Add a line to a point which has a certain angle.
-- Default arguments. (if an argument is not given to a function then it assumes that a certain argument has a certain value instead of erroring out.)
-
-'''
-
-
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-class triangle:
-	def __init__(self, *arguments):
-
-
-		self.debug = False
-		
-		# {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.default_arguments = {"x0":0, "y0":0, "x1":0, "y1":0, "x2":0, "y2":0} # list of tuples which are all 0,0
-
-		self.parameters = ["x0", "y0", "x1", "y1", "x2", "y2"]
-		
-		self.method_strings = ["set_lines_from_points"]
-		self.methods = [set_lines_from_points]
-
-		self.num_args = [3]
-		self.method_arg_types = [["point", "point", "point"]]
-
-		common_arg_stuff(self, *arguments)
-
-
-		'''
-				self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def get_range(self,x0,y0,x1,y1):
-
-		# spaghetti code
-
-		# get the range of numbers:
-		
-		output = []
-
-		if x0 > x1:
-			output.append("x>="+str(x1))
-			output.append("x<="+str(x0))
-		else:
-			output.append("x<="+str(x1))
-			output.append("x>="+str(x0))
-
-		if y0 > y1:
-			output.append("y>="+str(y1))
-			output.append("y<="+str(y0))
-		else:
-			output.append("y<="+str(y1))
-			output.append("y>="+str(y0))
-
-		return output
-
-
-
-
-	def get_line_equation(self,x0,y0,x1,y1):
-
-		# a,b = [[(y0-y1)/(x0*y1-x1*y0),(-x0+x1)/(x0*y1-x1*y0)]]   and c=1
-		a = simplify("(({})-({}))/(({}*{})-({}*{}))".format(str(y0), str(y1), str(x0), str(y1), str(x1), str(y0)))
-		b = simplify("(-({})+({}))/(({}*{})-({}*{}))".format(str(x0), str(x1), str(x0), str(y1), str(x1), str(y0)))
-		c = "1"
-		return "({})*x+({})*y+1=0".format(str(a), str(b))
-
-
-
-	def get_equations(self):
-
-		# basically just return the list of lines, except that there are constrictions on the answers
-
-		line_equations = [get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x2, self.y2)]
-
-		constraints = []
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x1, self.y1)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x2, self.y2)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x3, self.y3)
-
-		final_eqs = []
-
-		for i in range(3):
-
-			equation = line_equations[i]
-			constraint_thing = constraints[i]
-
-			final_equation = equation + constraint_thing
-
-			final_eqs.append([final_equation])
-
-		return final_eqs
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	def set_lines_from_points(self, point1, point2, point3):
-
-		self.x0 = point1.x
-		self.y0 = point1.y
-
-		self.x1 = point2.x
-		self.y1 = point2.y
-
-		self.x2 = point3.x
-		self.y2 = point3.y
-
-
-
-
-
-'''
-
- - Polygon which has X points.
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-'''
-# def mindistobjdot(command:str, objects:list):
-
-
-def polygon_command(command_string: str, objects: list):
-
-	# basically three lines.
-
-	# one point is line1 int line2  second point is line2 int line3  and third is line3 int line1
-
-	arguments = command_string.split(" ")
-
-	lines = arguments[1:]
-
-	line_objects = []
-
-	for line in lines:
-
-		line_objects.append(get_object_by_name(line))
-
-
-
-
-
-	
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	#x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	#y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	#x_is_var = False
-
-	#solutions = sympy.solve(object_equations,"x,y")
-	sol_x = sympy.solve(object_equations,"x")
-	sol_y = sympy.solve(object_equations,"y")
-
-
-	print("sol_x : "+str(sol_x))
-	print("sol_y : "+str(sol_y))
-	if isinstance(sol_x, list):
-		sol_x = sol_x[0]
-		sol_y = sol_y[0]
-
-
-	thing = sol_x
-	substitution = thing.update(sol_y)
-	print("substitution: "+str(substitution))
-	print("thing: "+str(thing))
-
-	#print("Solutions: "+str(solutions))
-
-
-
-	#y0 = y0[list(y0.keys())[0]]
-
-	x = Symbol('x')
-	y = Symbol('x')
-	distance_function = distance_thing(x,y,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-	distance_function = distance_function.subs(thing)
-	print("Substituted distance function: "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	
-	print("f: "+str(f))
-	if not maximumthing:
-
-		solution = minimum(f, x)
-	else:
-		solution = maximum(f, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/frjngjkgnrekngrejnrknrk.py b/frjngjkgnrekngrejnrknrk.py
deleted file mode 100644
index 23a711f..0000000
--- a/frjngjkgnrekngrejnrknrk.py
+++ /dev/null
@@ -1,1650 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/geometrylib.py b/geometrylib.py
index 44d70c6..baf520f 100644
--- a/geometrylib.py
+++ b/geometrylib.py
@@ -109,7 +109,12 @@ class point:
 				arguments_for_method.append(object_itself)
 			else:
 				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
+				#arguments_for_method.append(float(arguments[i]))
+
+				if is_expr(arguments[i]):
+					arguments_for_method.append(parse_expr(arguments[i]))
+				else:
+					arguments_for_method.append(float(arguments[i]))
 
 		# call the method with the arguments:
 
@@ -300,7 +305,12 @@ class triangle:
 				arguments_for_method.append(object_itself)
 			else:
 				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
+				#arguments_for_method.append(float(arguments[i]))
+
+				if is_expr(arguments[i]):
+					arguments_for_method.append(parse_expr(arguments[i]))
+				else:
+					arguments_for_method.append(float(arguments[i]))
 
 		# call the method with the arguments:
 
@@ -573,6 +583,17 @@ def common_arg_stuff(the_object, *arguments_thing):
 		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
 	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
 
+def is_expr(string:str) -> bool:
+	float_stuff = "0123456789." # These are all which are used to represent a float
+
+	for char in string:
+		if char not in float_stuff:
+			# The argument is not a float. return true , because therefore the string is actually an expression
+			return True
+	return False
+
+
+
 class line:
 	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
 	def __init__(self,*arguments):
@@ -694,10 +715,15 @@ class line:
 		print("type(point1.x) == "+str(type(point1.x)))
 
 
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
+		#point1.x = float(point1.x)
+		#point1.y = float(point1.y)
+		#point2.x = float(point2.x)
+		#point2.y = float(point2.y)
+
+		#point1.x = parse_expr(point1.x)
+		#point1.y = parse_expr(point1.y)
+		#point2.x = parse_expr(point2.x)
+		#point2.y = parse_expr(point2.y)
 
 		line_vector_x = -1*point1.x+point2.x
 		line_vector_y = -1*point1.y+point2.y
@@ -823,7 +849,13 @@ class line:
 				arguments_for_method.append(object_itself)
 			else:
 				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
+				#arguments_for_method.append(float(arguments[i]))
+				# do NOT assume a constant. check if it is an expression first.
+
+				if is_expr(arguments[i]):
+					arguments_for_method.append(parse_expr(arguments[i]))
+				else:
+					arguments_for_method.append(float(arguments[i]))
 
 		# call the method with the arguments:
 
diff --git a/geometrylibbackupthing.py b/geometrylibbackupthing.py
deleted file mode 100644
index 0aa3185..0000000
--- a/geometrylibbackupthing.py
+++ /dev/null
@@ -1,710 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects"]
-
-
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-	def __init__(self, x=None, y=None, vector=None):
-		if vector != None:
-			self.vector = vector
-			self.x=vector.item(0)
-			self.y=vector.item(1)
-		elif x==None and y==None:
-			warn("Warning. Uninitialized point.")
-			return
-		else:
-			self.vector = np.array([[x],[y]])
-			self.x = x
-			self.y = y
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	
-		
-
-def get_object_by_name(name_str):
-
-	count = 0
-	obj = global_objects[0]
-	while obj.name != name_str and count != len(global_objects):
-		obj = global_objects[count]
-		count += 1
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-
-class line:
-	def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(point1, point2):
-
-		# get vector from point1 to point2
-
-		from1to2 = -1*point1+point2
-
-		self.set_values_point_line(point1, from1to2)
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(method_string, command):
-		# global_objects
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-		self.debug=False
-		
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-
-
-	def replace_equation_shit(self):
-		return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-
-	for equation1, equation2 in zip(equations1, equations2):
-
-
-
-
-		temp_var_x = Symbol("tempvarx")
-		temp_var_y = Symbol("tempvary")
-
-		substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-		substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-		print("substitute_first : " + str(substitute_first))
-
-		equation1 = equation1.subs(substitute_first)
-
-		equation2 = equation2.subs(substitute_second)
-
-		print("-----------")
-		print(equation1)
-		print(equation2)
-		print("-----------")
-		print(temp_var_x)
-		print(temp_var_y)
-
-		result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-		print("result: "+str(result))
-		results.append(result)
-	return results
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-
-		setattr(object, attribute, value)
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	print("args : "+str(args))
-	if set_attributes(new_line, args):
-		return 1
-
-	print_col(bcolors.OKGREEN, "Created new object: ")
-	print(new_line)
-
-	objects.append(new_line)
-	global_objects.append(new_line)
-
-
-
-
-
-
-
-
-
-	return 0
-
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-
-	print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	obj.run_method_on_self(method_str, command_string)
-	#function = getattr(obj, method_str, None)
-
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects"]
-	min_arg_lengths = [0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-
-				if len(command_string.split(" ")) == 1:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/iiiiii.py b/iiiiii.py
deleted file mode 100644
index 1949ed3..0000000
--- a/iiiiii.py
+++ /dev/null
@@ -1,2049 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-
-
-
-
-'''
-
-
-Todo list:
-
-- Add a polygon object or atleast a triangle.
-- Way to compute angles and add an angle object. (Basically use stuff like the law of sines to compute them etc etc.)
-- 3D-objects.
-- Add a line to a point which has a certain angle.
-- Default arguments. (if an argument is not given to a function then it assumes that a certain argument has a certain value instead of erroring out.)
-
-'''
-
-
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-class triangle:
-	def __init__(self, *arguments):
-
-
-		self.debug = False
-		
-		# {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.default_arguments = {"x0":0, "y0":0, "x1":0, "y1":0, "x2":0, "y2":0} # list of tuples which are all 0,0
-
-		self.parameters = ["x0", "y0", "x1", "y1", "x2", "y2"]
-		
-		self.method_strings = ["set_lines_from_points"]
-		self.methods = [set_lines_from_points]
-
-		self.num_args = [3]
-		self.method_arg_types = [["point", "point", "point"]]
-
-		common_arg_stuff(self, *arguments)
-
-
-		'''
-				self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def get_range(self,x0,y0,x1,y1):
-
-		# spaghetti code
-
-		# get the range of numbers:
-		
-		output = []
-
-		if x0 > x1:
-			output.append("x>="+str(x1))
-			output.append("x<="+str(x0))
-		else:
-			output.append("x<="+str(x1))
-			output.append("x>="+str(x0))
-
-		if y0 > y1:
-			output.append("y>="+str(y1))
-			output.append("y<="+str(y0))
-		else:
-			output.append("y<="+str(y1))
-			output.append("y>="+str(y0))
-
-		return output
-
-
-
-
-	def get_line_equation(self,x0,y0,x1,y1):
-
-		# a,b = [[(y0-y1)/(x0*y1-x1*y0),(-x0+x1)/(x0*y1-x1*y0)]]   and c=1
-		a = simplify("(({})-({}))/(({}*{})-({}*{}))".format(str(y0), str(y1), str(x0), str(y1), str(x1), str(y0)))
-		b = simplify("(-({})+({}))/(({}*{})-({}*{}))".format(str(x0), str(x1), str(x0), str(y1), str(x1), str(y0)))
-		c = "1"
-		return "({})*x+({})*y+1=0".format(str(a), str(b))
-
-
-
-	def get_equations(self):
-
-		# basically just return the list of lines, except that there are constrictions on the answers
-
-		line_equations = [get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x1, self.y1), get_line_equation(self.x0, self.y0, self.x2, self.y2)]
-
-		constraints = []
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x1, self.y1)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x2, self.y2)
-
-		constraints.append += get_ranges(self.x0, self.y0, self.x3, self.y3)
-
-		final_eqs = []
-
-		for i in range(3):
-
-			equation = line_equations[i]
-			constraint_thing = constraints[i]
-
-			final_equation = equation + constraint_thing
-
-			final_eqs.append([final_equation])
-
-		return final_eqs
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	def set_lines_from_points(self, point1, point2, point3):
-
-		self.x0 = point1.x
-		self.y0 = point1.y
-
-		self.x1 = point2.x
-		self.y1 = point2.y
-
-		self.x2 = point3.x
-		self.y2 = point3.y
-
-
-
-
-
-'''
-
- - Polygon which has X points.
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-'''
-# def mindistobjdot(command:str, objects:list):
-
-
-def polygon_command(command_string: str, objects: list):
-
-	# basically three lines.
-
-	# one point is line1 int line2  second point is line2 int line3  and third is line3 int line1
-
-	arguments = command_string.split(" ")
-
-	lines = arguments[1:]
-
-	line_objects = []
-
-	for line in lines:
-
-		line_objects.append(get_object_by_name(line))
-
-
-
-
-
-	
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-def solve_equation_stuff(object_list, variables):
-	equations = []
-
-	for obj in object_list:
-		stuff = obj.get_equations()
-		
-		if isinstance(stuff, list):
-			
-			# this is for compatibility if the get_equations function returns a list of equations
-			equations += stuff
-		else:
-			equations.append(stuff)
-	plain_eqs = True
-
-	for eq in equations:
-		if isinstance(eq, list):
-			plain_eqs = False
-			break
-
-	if plain_eqs:  # they are plain equations without any constraints (aka a line and a point for example)
-
-		all_equations = equations
-		print("All equations as a list: "+str(all_equations))
-
-
-		result = sympy.solve(all_equations, variables)
-		print("result: "+str(result))
-	
-	else:
-		result = []
-
-		or_eqs = []
-		plain_eqs = []
-
-		for eq in equations:
-
-			if not isinstance(eq, list):
-				plain_eqs.append(eq)
-			else:
-				or_eqs.append(eq)
-
-			for or_eq1 in or_eqs:
-
-				result.append(solve([or_eq1]+plain_eqs), variables)
-
-	return result
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-
-
-	results = solve_equation_stuff([object1, object2], ('x','y'))
-	return results
-
-	
-	'''
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	plain_eqs = True
-
-	for eq in equations1:
-		if isinstance(eq, list):
-			plain_eqs = False
-			break
-	if plain_eqs:
-		for eq in equations2:
-			if isinstance(eq, list):
-				plain_eqs = False
-				break
-
-	if plain_eqs:  # they are plain equations without any constraints (aka a line and a point for example)
-
-		all_equations = equations1 + equations2
-		print("All equations as a list: "+str(all_equations))
-
-
-		result = sympy.solve(all_equations, ('x', 'y'))
-		print("result: "+str(result))
-	else:
-		result = []
-		plain_eqs = []
-
-		or_eqs1 = []
-		or_eqs2 = []
-
-		for eq in equations1:
-			if not isinstance(eq, list):
-				plain_eqs.append(eq)
-			else:
-				or_eqs1.append(eq)
-
-		for eq in equations2:
-			if not isinstance(eq, list):
-				plain_eqs.append(eq)
-			else:
-				or_eqs2.append(eq)
-
-		if or_eqs1 != [] and or_eqs2 != []:
-
-			for or_eq1 in or_eqs1:
-				for or_eq2 in or_eqs2:
-
-					result.append(solve([or_eq1, or_eq2]+plain_eqs), ('x', 'y'))
-		elif or_eqs1 != [] and or_eqs2 == []:
-
-			for or_eq1 in or_eqs1:
-
-
-				result.append(solve([or_eq1]+plain_eqs), ('x', 'y'))
-
-		elif or_eqs1 == [] and or_eqs2 != []:
-			for or_eq2 in or_eqs2:
-				result.append(solve([or_eq2]+plain_eqs), ('x', 'y'))
-
-		else:
-			# We should not reach this point here.
-			print("Something went wrong in intersection.")
-			exit(1)
-	return result
-	
-	'''
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	print("arguments: "+str(arguments))
-	print("object_name: "+str(object_name))
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	#x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	#y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	#x_is_var = False
-
-	#solutions = sympy.solve(object_equations,"x,y")
-	sol_x = sympy.solve(object_equations,"x")
-	sol_y = sympy.solve(object_equations,"y")
-
-
-	print("sol_x : "+str(sol_x))
-	print("sol_y : "+str(sol_y))
-	if isinstance(sol_x, list):
-		sol_x = sol_x[0]
-		sol_y = sol_y[0]
-
-
-	thing = sol_x
-	thing.update(sol_y)
-	print("substitution: "+str(thing))
-	print("thing: "+str(thing))
-
-	#print("Solutions: "+str(solutions))
-
-
-
-	#y0 = y0[list(y0.keys())[0]]
-
-	x = Symbol('x')
-	y = Symbol('y')
-	distance_function = distance_thing(x,y,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-
-
-	print("distance_function : "+str(distance_function))
-	distance_function = distance_function.subs(thing)
-	print("Substituted distance function: "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	
-	print("f: "+str(f))
-	if not maximumthing:
-
-		solution = minimum(f, x)
-	else:
-		solution = maximum(f, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	print("dot_thing: "+str(dot_thing))
-	print("object_thing: "+str(object_thing))
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	print("Resulting dict: "+str(resulting_dict))
-
-	oofstring1 = str(result[0][0])
-	oofstring2 = str(result[0][1])
-
-	print("oofstring1: "+str(oofstring1))
-	print("oofstring2: "+str(oofstring2))
-
-	oofstring1 = ''.join(oofstring1.split(" ")) # get rid of spaces
-	oofstring2 = ''.join(oofstring2.split(" "))
-
-	print("oofstring1 after: "+str(oofstring1))
-
-	print("oofstring2 after: "+str(oofstring2))
-
-	final_dict = {'x':oofstring1, 'y':oofstring2}
-	print("final_dict: "+str(final_dict))
-	return final_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	print("new_command_string == "+str(new_command_string))
-	print("Running subcommand: "+str(commands[index]))
-
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-	print("Returned from the assignment command:")
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/lll.txt b/lll.txt
deleted file mode 100644
index 27dc4a6..0000000
--- a/lll.txt
+++ /dev/null
@@ -1,1943 +0,0 @@
-Running test check_var_assignment_to_function_result.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_assignment_to_function_result.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1']
-global_objects at the start: ['myline1']
-objects after creation of new_object : ['myline1']
-gregregregrr
-global_objects at the start: ['myline1', 'line0']
-objects after appending new_object: ['myline1', 'line0']
-global_objects after appending new_object: ['myline1', 'line0']
-objects at the end: ['myline1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == None
-end == None
-var_values final: {x: 1, y: -2}
-arguments: ['x=1', 'y=-2']
-object_name: point
-{'x': '1', 'y': '-2'}
-*arguments_thing : {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2']
-global_objects at the start: ['myline1', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = -2
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = -2name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[92mTestsuite tests/check_var_assignment_to_function_result.txt passed![0m
-Running test check_line_intersect.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_intersect.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['line0']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line1
-setting parameter a to this: a1
-the_object.name == line1
-setting parameter b to this: b1
-the_object.name == line1
-setting parameter c to this: c1
-the_object.name == line1
-setting parameter x to this: x1
-the_object.name == line1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['line0']
-global_objects at the start: ['line0']
-objects after creation of new_object : ['line0']
-gregregregrr
-global_objects at the start: ['line0', 'line1']
-objects after appending new_object: ['line0', 'line1']
-global_objects after appending new_object: ['line0', 'line1']
-objects at the end: ['line0', 'line1']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect line0 line1
-fewfeewfewfewf
-Args : ['intersect', 'line0', 'line1']
-obj_name1 : line0
-obj_name2 : line1
-name_str: line0
-['line0', 'line1']
----------------------------
-line0
-line1
----------------------------
-name_str: line1
-['line0', 'line1']
----------------------------
-line0
-line1
----------------------------
-obj.name == line0
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Command result: {x: 1, y: -2}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {x: 1, y: -2}
-Expected final result: {x: 1, y: -2}
-command_result: {x: 1, y: -2}
-expected_result: {x: 1, y: -2}
-[92mTestsuite tests/check_line_intersect.txt passed![0m
-Running test check_var_subsequences.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_subsequences.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1']
-global_objects at the start: ['myline1']
-objects after creation of new_object : ['myline1']
-gregregregrr
-global_objects at the start: ['myline1', 'line0']
-objects after appending new_object: ['myline1', 'line0']
-global_objects after appending new_object: ['myline1', 'line0']
-objects at the end: ['myline1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar][0:1]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == 0
-end == 1
-abcdefg
-l == (x,)
-var_values final: {x: 1}
-arguments: ['x=1']
-object_name: point
-{'x': '1'}
-*arguments_thing : {'x': '1'}
-bullshit: {'x': '1'}
-bullshit: {'x': '1'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2']
-global_objects at the start: ['myline1', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = y0
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = y0name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = y0name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[91mTestsuite tests/check_var_subsequences.txt failed![0m
-Running test check_max_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_max_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline']
-global_objects at the start: ['myline']
-objects after creation of new_object : ['myline']
-gregregregrr
-global_objects at the start: ['myline', 'point0']
-objects after appending new_object: ['myline', 'point0']
-global_objects after appending new_object: ['myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: maxdistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-name_str: mypoint
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-obj.name == myline
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: oo
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Maximum distance: oo
-Command result: oo
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: oo
-Expected final result: oo
-command_result: oo
-expected_result: oo
-[92mTestsuite tests/check_max_output_dot_line.txt passed![0m
-Running test check_intersection_triangle_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_intersection_triangle_circle.txt.
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['triangle0']
-objects after appending new_object: ['triangle0']
-global_objects after appending new_object: ['triangle0']
-Command result: 0
-Command string: circle xc=0.8 yc=0.4 r=0.3
-fewfeewfewfewf
-arguments: ['xc=0.8', 'yc=0.4', 'r=0.3']
-object_name: circle
-{'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-*arguments_thing : {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['triangle0']
-global_objects at the start: ['triangle0']
-objects after creation of new_object : ['triangle0']
-gregregregrr
-global_objects at the start: ['triangle0', 'circle0']
-objects after appending new_object: ['triangle0', 'circle0']
-global_objects after appending new_object: ['triangle0', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 circle0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'circle0']
-obj_name1 : triangle0
-obj_name2 : circle0
-name_str: triangle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-name_str: circle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7fd024df2a90>
-obj2: =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7fd024df2a90>
-object2 : =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.circle'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-Circle equation bullshit: 
-((x)-(0.8))**2+((y)-(0.4))**2=(0.3)**2
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-Final plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, 5*x - 30*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 0.648031893339682, 'y': 0.141338648889947}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 1.02764378233599, 'y': 0.204607297055999}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, -3*x + 2*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.523076923076923, 'y': 0.284615384615385}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.800000000000000, 'y': 0.700000000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[1, x]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-poopoo
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.176393202250021}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.623606797749979}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}][0m
-Command result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Expected final result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-command_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-expected_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-[92mTestsuite tests/check_intersection_triangle_circle.txt passed![0m
-Running test check_integral.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_integral.txt.
-Command string: integrate y=x**2 x 1 3
-fewfeewfewfewf
-selected_expr: Eq(y, x**2)
-[-x**2 + y]
-[y]
-ok so it is a bare function and not a system of equations
-y_function: [x**2]
-[33mResult: 26/3[0m
-Command result: 26/3
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 26/3
-Expected final result: 26/3
-command_result: 26/3
-expected_result: 26/3
-[92mTestsuite tests/check_integral.txt passed![0m
-Running test check_point_on_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['point0']
-objects after appending new_object: ['point0']
-global_objects after appending new_object: ['point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-arguments: []
-object_name: circle
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mypoint']
-global_objects at the start: ['mypoint']
-objects after creation of new_object : ['mypoint']
-gregregregrr
-global_objects at the start: ['mypoint', 'circle0']
-objects after appending new_object: ['mypoint', 'circle0']
-global_objects after appending new_object: ['mypoint', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-self.yc : yc0
-result: None
-Command string: mycircle.xc = 10
-thing
-==================================================================================
-Setting property : xc
-On object: mycircle
-selected_property: xc
-value: 10
-self.yc : yc0
-result: None
-Command string: mycircle.yc = 2
-thing
-==================================================================================
-Setting property : yc
-On object: mycircle
-selected_property: yc
-value: 2
-self.yc : yc0
-result: None
-Command string: mycircle.r = 3
-thing
-==================================================================================
-Setting property : r
-On object: mycircle
-selected_property: r
-value: 3
-self.yc : 2
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-name_str: mycircle
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-obj.name == mypoint
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-Circle equation bullshit: 
-((x)-(10))**2+((y)-(2))**2=(3)**2
-oof
-oof22
-All equations as a list: [Eq(x, 7.0), Eq(y, 2.0), Eq((x - 10)**2 + (y - 2)**2, 9)]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[[x - 7, (x - 10)**2 + (y - 2)**2 - 9, y - 2]]
-[7, x]
-[2, y]
-[9, (x - 10)**2 + (y - 2)**2]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-result: [(7.00000000000000, 2.00000000000000)]
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [(7.00000000000000, 2.00000000000000)][0m
-Results thing: [(7.00000000000000, 2.00000000000000)]
-Command result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Expected final result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-command_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-expected_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-[92mTestsuite tests/check_point_on_circle.txt passed![0m
-Running test check_min_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline']
-global_objects at the start: ['myline']
-objects after creation of new_object : ['myline']
-gregregregrr
-global_objects at the start: ['myline', 'point0']
-objects after appending new_object: ['myline', 'point0']
-global_objects after appending new_object: ['myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-name_str: mypoint
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-obj.name == myline
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-Command result: 3*sqrt(5)/5
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 3*sqrt(5)/5
-Expected final result: 3*sqrt(5)/5
-command_result: 3*sqrt(5)/5
-expected_result: 3*sqrt(5)/5
-[92mTestsuite tests/check_min_output_dot_line.txt passed![0m
-Running test check_lines_angle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_lines_angle.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linefirst
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linefirst
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['linefirst']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['linefirst']
-global_objects at the start: ['linefirst']
-objects after creation of new_object : ['linefirst']
-gregregregrr
-global_objects at the start: ['linefirst', 'line0']
-objects after appending new_object: ['linefirst', 'line0']
-global_objects after appending new_object: ['linefirst', 'line0']
-objects at the end: ['linefirst', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linesecond
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linesecond
-result: None
-Command string: 
-Command string: angle_lines linefirst linesecond
-fewfeewfewfewf
-name_str: linefirst
-['linefirst', 'linesecond']
----------------------------
-linefirst
-linesecond
----------------------------
-name_str: linesecond
-['linefirst', 'linesecond']
----------------------------
-linefirst
-linesecond
----------------------------
-obj.name == linefirst
-[94mAngle between lines: -57.2957795130823*atan(1/2) + 57.2957795130823*atan(4/5) == 12.0947570770121[0m
-Command result: 12.0947570770121
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 12.0947570770121
-Expected final result: 12.0947570770121
-command_result: 12.0947570770121
-expected_result: 12.0947570770121
-[92mTestsuite tests/check_lines_angle.txt passed![0m
-Running test check_line_triangle_intersection.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_triangle_intersection.txt.
-Command string: 
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['triangle0']
-objects after appending new_object: ['triangle0']
-global_objects after appending new_object: ['triangle0']
-Command result: 0
-Command string: line a=0.1 b=1 c=-0.5
-fewfeewfewfewf
-objects at the start: ['triangle0']
-arguments: ['a=0.1', 'b=1', 'c=-0.5']
-object_name: line
-{'a': '0.1', 'b': '1', 'c': '-0.5'}
-*arguments_thing : {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['triangle0']
-global_objects at the start: ['triangle0']
-objects after creation of new_object : ['triangle0']
-gregregregrr
-global_objects at the start: ['triangle0', 'line0']
-objects after appending new_object: ['triangle0', 'line0']
-global_objects after appending new_object: ['triangle0', 'line0']
-objects at the end: ['triangle0', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 line0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'line0']
-obj_name1 : triangle0
-obj_name2 : line0
-name_str: triangle0
-['triangle0', 'line0']
----------------------------
-triangle0
-line0
----------------------------
-name_str: line0
-['triangle0', 'line0']
----------------------------
-triangle0
-line0
----------------------------
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7fd024c563d0>
-obj2: =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7fd024c563d0>
-object2 : =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.line'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq(0.1*x + y - 0.5, 0)]
-Final plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[[5*x - 30*y + 1, x/10 + y - 1/2]]
-[-1, 5*x - 30*y]
-[1/2, x/10 + y]
-Matrix([[5, -30, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: {x: 1.75000000000000, y: 0.325000000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {x: 1.75000000000000, y: 0.325000000000000}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[[-3*x + 2*y + 1, x/10 + y - 1/2]]
-[-1, -3*x + 2*y]
-[1/2, x/10 + y]
-Matrix([[-3, 2, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: {x: 0.625000000000000, y: 0.437500000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {x: 0.625000000000000, y: 0.437500000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[[1 - x, x/10 + y - 1/2]]
-[1, x]
-[1/2, x/10 + y]
-Matrix([[1, 0, 1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: {x: 1.00000000000000, y: 0.400000000000000}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {x: 1.00000000000000, y: 0.400000000000000}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}][0m
-Command result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Expected final result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-command_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-expected_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-[92mTestsuite tests/check_line_triangle_intersection.txt passed![0m
-Running test check_area_between_intersections.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_area_between_intersections.txt.
-Command string: 
-Command string: line a=4 b=-2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=4', 'b=-2', 'c=3']
-object_name: line
-{'a': '4', 'b': '-2', 'c': '3'}
-*arguments_thing : {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: area_between_intersections myline y=x**2-10*x+10
-fewfeewfewfewf
-name_str: myline
-['myline']
----------------------------
-myline
----------------------------
-oof
-oof22
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]]
-[-3, 4*x - 2*y]
-[10, -x**2 + 10*x + y]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-intersection_points == [(6 - sqrt(110)/2, 27/2 - sqrt(110)), (sqrt(110)/2 + 6, sqrt(110) + 27/2)]
-thingoof intersection_x_values ==
-[4*x - 2*y + 0 + 3]
-[y]
-ok so it is a bare function and not a system of equations
-[-x**2 + 10*x + y - 10]
-[y]
-ok so it is a bare function and not a system of equations
-functions_in_y_format == [[2*x + 3/2], [x**2 - 10*x + 10]]
-bigger function: 2*x + 3/2
-smaller_fun : x**2 - 10*x + 10
-Difference function: -x**2 + 12*x - 17/2
-intersection_x_values[0] == 6 - sqrt(110)/2
-intersection_x_values[1] == sqrt(110)/2 + 6
-[33mArea: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2[0m
-Command result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-Expected final result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-command_result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-expected_result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-[92mTestsuite tests/check_area_between_intersections.txt passed![0m
-Running test check_min_dist_point_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_dist_point_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline']
-global_objects at the start: ['myline']
-objects after creation of new_object : ['myline']
-gregregregrr
-global_objects at the start: ['myline', 'point0']
-objects after appending new_object: ['myline', 'point0']
-global_objects after appending new_object: ['myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistpointobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-name_str: mypoint
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-obj.name == myline
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-name_str: mypoint
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-obj.name == myline
-name_str: myline
-['myline', 'mypoint']
----------------------------
-myline
-mypoint
----------------------------
-oof
-oof22
-radiuses : 3*sqrt(5)/5
-Returning this: (x-0.0)**2+(y-0.0)**2=(3*sqrt(5)/5)**2
-circle_equation : [Eq(x**2 + y**2, 9/5)]
-all equations: [Eq(x + 2*y + 3, 0), Eq(x**2 + y**2, 9/5)]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]]
-[-3, x + 2*y]
-[9/5, x**2 + y**2]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-Result: [(-3/5, -6/5)]
-Resulting dict: {'x': -3/5, 'y': -6/5}
-oofstring1: -3/5
-oofstring2: -6/5
-oofstring1 after: -3/5
-oofstring2 after: -6/5
-final_dict: {'x': '-3/5', 'y': '-6/5'}
-Command result: {'x': '-3/5', 'y': '-6/5'}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': '-3/5', 'y': '-6/5'}
-Expected final result: {'x': '-3/5', 'y': '-6/5'}
-command_result: {'x': '-3/5', 'y': '-6/5'}
-expected_result: {'x': '-3/5', 'y': '-6/5'}
-[92mTestsuite tests/check_min_dist_point_line.txt passed![0m
-results list: [True, True, False, True, True, True, True, True, True, True, True, True]
-[94m=================================================
-
-[0m
-[94mFinal results: 
-[0m
-[92mTest: tests/check_var_assignment_to_function_result.txt PASSED![0m
-[92mTest: tests/check_line_intersect.txt PASSED![0m
-[91mTest: tests/check_var_subsequences.txt FAILED![0m
-[92mTest: tests/check_max_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_intersection_triangle_circle.txt PASSED![0m
-[92mTest: tests/check_integral.txt PASSED![0m
-[92mTest: tests/check_point_on_circle.txt PASSED![0m
-[92mTest: tests/check_min_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_lines_angle.txt PASSED![0m
-[92mTest: tests/check_line_triangle_intersection.txt PASSED![0m
-[92mTest: tests/check_area_between_intersections.txt PASSED![0m
-[92mTest: tests/check_min_dist_point_line.txt PASSED![0m
-
-
-
-[91mSome tests failed!
-
-[0m
-[94m=================================================[0m
diff --git a/nfrjkgnrejkgnrk.py b/nfrjkgnrejkgnrk.py
deleted file mode 100644
index 4e944c2..0000000
--- a/nfrjkgnrejkgnrk.py
+++ /dev/null
@@ -1,1679 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	#x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	#y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	#x_is_var = False
-
-	#solutions = sympy.solve(object_equations,"x,y")
-	sol_x = sympy.solve(object_equations,"x")
-	sol_y = sympy.solve(object_equations,"y")
-
-
-	print("sol_x : "+str(sol_x))
-	print("sol_y : "+str(sol_y))
-	if isinstance(sol_x, list):
-		sol_x = sol_x[0]
-		sol_y = sol_y[0]
-
-
-	thing = sol_x
-	substitution = thing.update(sol_y)
-	print("substitution: "+str(substitution))
-	print("thing: "+str(thing))
-
-	#print("Solutions: "+str(solutions))
-
-
-
-	#y0 = y0[list(y0.keys())[0]]
-
-	x = Symbol('x')
-	y = Symbol('x')
-	distance_function = distance_thing(x,y,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-	distance_function = distance_function.subs(thing)
-	print("Substituted distance function: "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	
-	print("f: "+str(f))
-	if not maximumthing:
-
-		solution = minimum(f, x)
-	else:
-		solution = maximum(f, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/notes.txt b/notes.txt
deleted file mode 100644
index e0331d7..0000000
--- a/notes.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-
-The parameters to the function are passed improperly because:
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	print("Resulting dict: "+str(resulting_dict))
-
-	return resulting_dict
-
-
-this causes resulting_dict to have stuff like {'x':2*sqrt(3) + 1 ... }  which then parsed as arguments to the next function gets parsed as: "x=2*sqrt()" "+" "1" etc and those are of course invalid.
-
diff --git a/oofshit.txt b/oofshit.txt
deleted file mode 100644
index 60a6d50..0000000
--- a/oofshit.txt
+++ /dev/null
@@ -1,132 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['point0']
-objects after appending new_object: ['point0']
-global_objects after appending new_object: ['point0']
-Command string: point0.name = mypoint
-thing
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mypoint']
-global_objects at the start: ['mypoint']
-objects after creation of new_object : ['mypoint']
-gregregregrr
-global_objects at the start: ['mypoint', 'circle0']
-objects after appending new_object: ['mypoint', 'circle0']
-global_objects after appending new_object: ['mypoint', 'circle0']
-[92mCreated new object.[0m
-Command string: circle0.name = mycircle
-thing
-selected_property: name
-value: mycircle
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-name_str: mycircle
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-obj.name == mypoint
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: <__main__.circle object at 0x7f9ea4d9b130>
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : <__main__.circle object at 0x7f9ea4d9b130>
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-oof
-oof22
-bullshit
-equation : Eq(x, 7.0)
-"x"+str(object1.var_count) == x0
-equation : Eq(y, 2.0)
-"x"+str(object1.var_count) == x0
-substituted_equations
-Eq(x, 7.0)
-Eq(y, 2.0)
-Eq((tempvarx - xc0)**2 + (tempvary - yc0)**2, r0**2)
-[-r0**2 + (tempvarx - xc0)**2 + (tempvary - yc0)**2]
-[tempvarx, tempvary]
-[-r0**2 + (tempvarx - xc0)**2 + (tempvary - yc0)**2]
-[tempvarx, tempvary]
-[[-r0**2 + (tempvarx - xc0)**2 + (tempvary - yc0)**2]]
-[r0**2, (tempvarx - xc0)**2 + (tempvary - yc0)**2]
-[Poly(tempvarx**2 - 2*xc0*tempvarx + tempvary**2 - 2*yc0*tempvary - r0**2 + xc0**2 + yc0**2, tempvarx, tempvary, domain='ZZ[r0,xc0,yc0]')]
-[Poly(tempvarx**2 - 2*xc0*tempvarx + tempvary**2 - 2*yc0*tempvary - r0**2 + xc0**2 + yc0**2, tempvarx, tempvary, domain='ZZ[r0,xc0,yc0]')]
-[Poly(tempvarx**2 - 2*xc0*tempvarx + tempvary**2 - 2*yc0*tempvary - r0**2 + xc0**2 + yc0**2, tempvarx, tempvary, domain='ZZ[r0,xc0,yc0]')]
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [][0m
-[94m>>> [0m
\ No newline at end of file
diff --git a/oofshit/thing.py b/oofshit/thing.py
deleted file mode 100644
index 7cb9f5a..0000000
--- a/oofshit/thing.py
+++ /dev/null
@@ -1,14 +0,0 @@
-import numpy as np
-import matplotlib.pyplot as plt
-
-from sympy import *
-x, y, z, t = symbols('x y z t')
-k, m, n = symbols('k m n', integer=True)
-f, g, h = symbols('f g h', cls=Function)
-f = simplify(x**2)
-f_comma = diff(f, x)
-eq = Eq(f_comma, 0)
-an_sol = solve(eq)
-
-print(an_sol)
-
diff --git a/oofthing.py b/oofthing.py
deleted file mode 100644
index 5778a9a..0000000
--- a/oofthing.py
+++ /dev/null
@@ -1,151 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-
-
-
-global_things = []
-
-class var:
-	def __init__(self, value):
-		if value ==
-
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-
-class point:
-	def __init__(self, x=None, y=None, vector=None):
-		if vector != None:
-			self.vector = vector
-			self.x=vector.item(0)
-			self.y=vector.item(1)
-		elif x==None and y==None:
-			warn("Warning. Uninitialized point.")
-			return
-		else:
-			self.vector = np.array([[x],[y]])
-			self.x = x
-			self.y = y
-
-	
-		
-
-
-
-class line:
-	def __init__(self,a="unknown",b="unknown",c="unknown"):
-
-
-		# a*x+b*x=c
-		self.debug=False
-
-		self.a = a
-		self.b = b
-		self.c = c
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		self.c = 1
-		
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = -(yv/(x0*yv-xv*y0))
-		self.b = xv/(x0*yv-xv*y0)
-
-		self.c = float(self.c)
-		self.a = float(self.a)
-		self.b = float(self.b)
-		return;
-
-	def set_values_two_points(point1, point2):
-
-		# get vector from point1 to point2
-
-		from1to2 = -1*point1+point2
-
-		self.set_values_point_line(point1, from1to2)
-
-	def get_equation(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*x+("+str(self.b)+")*y+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return Eq(equation_left_side, equation_right_side)
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-
-	print(line_object.get_equation())
-	x = Symbol('x')
-	print("thing")
-	#print(line_object.get_equation()[0])
-	print("thingooff")
-	print(solve(line_object.get_equation()), x)
-
-	return 0
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-
-	
-
-
-		
-
-
-
-
diff --git a/oofthing.txt b/oofthing.txt
deleted file mode 100644
index 481b7b0..0000000
--- a/oofthing.txt
+++ /dev/null
@@ -1,98 +0,0 @@
-COMMAND       PID        USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
-sublime_t   24130 cyberhacker  DEL    REG   0,27            91 /dev/shm/24130:subl_arecv-3.8
-sublime_t   24130 cyberhacker  DEL    REG   0,27            81 /dev/shm/24130:subl_recv-3.8
-sublime_t   24130 cyberhacker  DEL    REG   0,27            74 /dev/shm/24130:subl_send-3.8
-sublime_t   24130 cyberhacker  DEL    REG   0,27            97 /dev/shm/KnibzN
-sublime_t   24130 cyberhacker  DEL    REG   0,27            69 /dev/shm/24130:subl_arecv-3.3
-sublime_t   24130 cyberhacker  DEL    REG   0,27            41 /dev/shm/24130:subl_recv-3.3
-sublime_t   24130 cyberhacker  DEL    REG   0,27            16 /dev/shm/24130:subl_send-3.3
-sublime_t   24130 cyberhacker  DEL    REG   0,27            95 /dev/shm/k2s1bM
-sublime_t   24130 cyberhacker  DEL    REG   0,27            88 /dev/shm/vUgijN
-sublime_t   24130 cyberhacker  DEL    REG   0,27            84 /dev/shm/kDdpuP
-sublime_t   24130 cyberhacker  DEL    REG   0,27            78 /dev/shm/593mMM
-sublime_t   24130 cyberhacker  DEL    REG   0,27            77 /dev/shm/1PSlHL
-sublime_t   24130 cyberhacker  DEL    REG   0,27            73 /dev/shm/UGYcLM
-sublime_t   24130 cyberhacker  DEL    REG   0,27            70 /dev/shm/crhKUN
-sublime_t   24130 cyberhacker  DEL    REG   0,27            59 /dev/shm/u924JM
-sublime_t   24130 cyberhacker  DEL    REG   0,27            57 /dev/shm/77NyMP
-sublime_t   24130 cyberhacker  DEL    REG   0,27            38 /dev/shm/UbaWBO
-sublime_t   24130 cyberhacker  DEL    REG   0,27            24 /dev/shm/Dy0KXM
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            69 /dev/shm/24130:subl_arecv-3.3
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            73 /dev/shm/sem.24130:subl_arecv-3.3:w
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            70 /dev/shm/sem.24130:subl_arecv-3.3:r
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            38 /dev/shm/sem.24130:subl_send-3.3:w
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            24 /dev/shm/sem.24130:subl_send-3.3:r
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            16 /dev/shm/24130:subl_send-3.3
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            59 /dev/shm/sem.24130:subl_recv-3.3:w
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            41 /dev/shm/24130:subl_recv-3.3
-plugin_ho   24150 cyberhacker  DEL    REG   0,27            57 /dev/shm/sem.24130:subl_recv-3.3:r
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            91 /dev/shm/24130:subl_arecv-3.8
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            97 /dev/shm/sem.24130:subl_arecv-3.8:w
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            95 /dev/shm/sem.24130:subl_arecv-3.8:r
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            78 /dev/shm/sem.24130:subl_send-3.8:w
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            77 /dev/shm/sem.24130:subl_send-3.8:r
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            74 /dev/shm/24130:subl_send-3.8
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            88 /dev/shm/sem.24130:subl_recv-3.8:w
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            81 /dev/shm/24130:subl_recv-3.8
-plugin_ho   24153 cyberhacker  DEL    REG   0,27            84 /dev/shm/sem.24130:subl_recv-3.8:r
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27           225 /dev/shm/.org.chromium.Chromium.6NS2yv
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27           140 /dev/shm/.org.chromium.Chromium.k0LqUv
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27           148 /dev/shm/.org.chromium.Chromium.5PdQqt
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27            82 /dev/shm/.org.chromium.Chromium.rjEL2s
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27           136 /dev/shm/.org.chromium.Chromium.tr7kSt
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27           106 /dev/shm/.org.chromium.Chromium.GJcKpu
-GeoGebra  1101487 cyberhacker  DEL    REG   0,27            99 /dev/shm/.org.chromium.Chromium.PgLhIs
-GeoGebra  1101487 cyberhacker   60r   REG   0,27   131072   82 /dev/shm/.org.chromium.Chromium.rjEL2s (deleted)
-GeoGebra  1101487 cyberhacker   61u   REG   0,27        4   99 /dev/shm/.org.chromium.Chromium.PgLhIs (deleted)
-GeoGebra  1101487 cyberhacker   96u   REG   0,27      144  106 /dev/shm/.org.chromium.Chromium.GJcKpu (deleted)
-GeoGebra  1101487 cyberhacker   98u   REG   0,27      144  136 /dev/shm/.org.chromium.Chromium.tr7kSt (deleted)
-GeoGebra  1101487 cyberhacker  100u   REG   0,27  1048576  140 /dev/shm/.org.chromium.Chromium.k0LqUv (deleted)
-GeoGebra  1101487 cyberhacker  101u   REG   0,27    65536  148 /dev/shm/.org.chromium.Chromium.5PdQqt (deleted)
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           308 /dev/shm/.org.chromium.Chromium.6VcSr0
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           307 /dev/shm/.org.chromium.Chromium.ACw5x1
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           114 /dev/shm/.org.chromium.Chromium.rcaO40
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           196 /dev/shm/.org.chromium.Chromium.cEZpP1
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           184 /dev/shm/.org.chromium.Chromium.xRohJ0
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           140 /dev/shm/.org.chromium.Chromium.k0LqUv
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           182 /dev/shm/.org.chromium.Chromium.QPrDU1
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           159 /dev/shm/.org.chromium.Chromium.Bbj0p1
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           148 /dev/shm/.org.chromium.Chromium.5PdQqt
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           289 /dev/shm/.org.chromium.Chromium.W2UY12
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           136 /dev/shm/.org.chromium.Chromium.tr7kSt
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27           106 /dev/shm/.org.chromium.Chromium.GJcKpu
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27            99 /dev/shm/.org.chromium.Chromium.PgLhIs
-GeoGebra  1101519 cyberhacker  DEL    REG   0,27            82 /dev/shm/.org.chromium.Chromium.rjEL2s
-GeoGebra  1101519 cyberhacker   38u   REG   0,27        4   99 /dev/shm/.org.chromium.Chromium.PgLhIs (deleted)
-GeoGebra  1101519 cyberhacker   42u   REG   0,27      144  106 /dev/shm/.org.chromium.Chromium.GJcKpu (deleted)
-GeoGebra  1101519 cyberhacker   43u   REG   0,27  2097152  114 /dev/shm/.org.chromium.Chromium.rcaO40 (deleted)
-GeoGebra  1101519 cyberhacker   45u   REG   0,27      144  136 /dev/shm/.org.chromium.Chromium.tr7kSt (deleted)
-GeoGebra  1101519 cyberhacker   46u   REG   0,27  1048576  140 /dev/shm/.org.chromium.Chromium.k0LqUv (deleted)
-GeoGebra  1101519 cyberhacker   47u   REG   0,27    65536  148 /dev/shm/.org.chromium.Chromium.5PdQqt (deleted)
-GeoGebra  1101519 cyberhacker   49u   REG   0,27      144  159 /dev/shm/.org.chromium.Chromium.Bbj0p1 (deleted)
-GeoGebra  1101519 cyberhacker   52u   REG   0,27      144  182 /dev/shm/.org.chromium.Chromium.QPrDU1 (deleted)
-GeoGebra  1101519 cyberhacker   53u   REG   0,27    65536  184 /dev/shm/.org.chromium.Chromium.xRohJ0 (deleted)
-GeoGebra  1101519 cyberhacker   54u   REG   0,27    65536  196 /dev/shm/.org.chromium.Chromium.cEZpP1 (deleted)
-GeoGebra  1101519 cyberhacker   55u   REG   0,27      144  289 /dev/shm/.org.chromium.Chromium.W2UY12 (deleted)
-GeoGebra  1101519 cyberhacker   57u   REG   0,27  1048576  307 /dev/shm/.org.chromium.Chromium.ACw5x1 (deleted)
-GeoGebra  1101519 cyberhacker   58u   REG   0,27  2097152  308 /dev/shm/.org.chromium.Chromium.6VcSr0 (deleted)
-GeoGebra  1101525 cyberhacker  DEL    REG   0,27            82 /dev/shm/.org.chromium.Chromium.rjEL2s
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           308 /dev/shm/.org.chromium.Chromium.6VcSr0
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           307 /dev/shm/.org.chromium.Chromium.ACw5x1
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           114 /dev/shm/.org.chromium.Chromium.rcaO40
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           225 /dev/shm/.org.chromium.Chromium.6NS2yv
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           196 /dev/shm/.org.chromium.Chromium.cEZpP1
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           184 /dev/shm/.org.chromium.Chromium.xRohJ0
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           289 /dev/shm/.org.chromium.Chromium.W2UY12
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27            82 /dev/shm/.org.chromium.Chromium.rjEL2s
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           198 /dev/shm/.org.chromium.Chromium.JHSIH0
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           182 /dev/shm/.org.chromium.Chromium.QPrDU1
-GeoGebra  1101547 cyberhacker  DEL    REG   0,27           159 /dev/shm/.org.chromium.Chromium.Bbj0p1
-GeoGebra  1101547 cyberhacker   36u   REG   0,27      144  159 /dev/shm/.org.chromium.Chromium.Bbj0p1 (deleted)
-GeoGebra  1101547 cyberhacker   37u   REG   0,27  2097152  114 /dev/shm/.org.chromium.Chromium.rcaO40 (deleted)
-GeoGebra  1101547 cyberhacker   39u   REG   0,27      144  182 /dev/shm/.org.chromium.Chromium.QPrDU1 (deleted)
-GeoGebra  1101547 cyberhacker   40u   REG   0,27    65536  184 /dev/shm/.org.chromium.Chromium.xRohJ0 (deleted)
-GeoGebra  1101547 cyberhacker   42u   REG   0,27    65536  196 /dev/shm/.org.chromium.Chromium.cEZpP1 (deleted)
-GeoGebra  1101547 cyberhacker   54u   REG   0,27  4198400  225 /dev/shm/.org.chromium.Chromium.6NS2yv (deleted)
-GeoGebra  1101547 cyberhacker   79u   REG   0,27      144  289 /dev/shm/.org.chromium.Chromium.W2UY12 (deleted)
-GeoGebra  1101547 cyberhacker   80u   REG   0,27  1048576  307 /dev/shm/.org.chromium.Chromium.ACw5x1 (deleted)
-GeoGebra  1101547 cyberhacker   82u   REG   0,27  2097152  308 /dev/shm/.org.chromium.Chromium.6VcSr0 (deleted)
diff --git a/oooooooofshitoof.py b/oooooooofshitoof.py
deleted file mode 100644
index 30ef33e..0000000
--- a/oooooooofshitoof.py
+++ /dev/null
@@ -1,1142 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-		print(" self.x : "+str( self.x))
-		print("left_side_1 == " + str(left_side_1))
-		print("right_side_1 == "+str(right_side_1))
-		#first_eq = Eq("x", right_side_1)
-		#print(Eq(right_side_1, self.x))
-		print("Eq(right_side_1, self.x) == " + str((right_side_1, self.x)))
-
-		print("(left_side_1, self.x) == "+str((left_side_1, self.x)))
-		print("left_side_1 == "+str(left_side_1))
-		print(type(left_side_1))
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print(string_oof_1)
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-
-		self.b = sympy.simplify(string_oof_2)
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-	'''
-	for equation1, equation2 in zip(equations1, equations2):
-
-
-
-
-		temp_var_x = Symbol("tempvarx")
-		temp_var_y = Symbol("tempvary")
-
-		#substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-		#substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-
-		#substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x":temp_var_x, "y":temp_var_y}
-
-
-		substitute_first = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-		substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-
-
-
-		print("substitute_first : " + str(substitute_first))
-
-		equation1 = equation1.subs(substitute_first)
-
-		equation2 = equation2.subs(substitute_second)
-
-		print("-----------")
-		print(equation1)
-		print(equation2)
-		print("-----------")
-		print(temp_var_x)
-		print(temp_var_y)
-
-		result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-		print("result: "+str(result))
-		results.append(result)
-	'''
-
-	temp_var_x = Symbol("tempvarx")
-	temp_var_y = Symbol("tempvary")
-
-	substituted_equations = []
-
-	for equation in equations1:
-
-		substitute_first = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-	for equation in equations2:
-
-		substitute_first = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-
-	print("substituted_equations")
-	for eq in substituted_equations:
-		print(str(eq))
-
-
-	result = sympy.solve(substituted_equations, (temp_var_x, temp_var_y))
-
-	return results
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results != []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point"]
-	min_arg_lengths = [0,0,0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0,3,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/output.txt b/output.txt
deleted file mode 100644
index 870fc14..0000000
--- a/output.txt
+++ /dev/null
@@ -1,229 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file sivu142tehtävä15.txt.
-Command string: 
-Command string: circle xc=20 yc=10 r=10
-fewfeewfewfewf
-arguments: ['xc=20', 'yc=10', 'r=10']
-object_name: circle
-{'xc': '20', 'yc': '10', 'r': '10'}
-*arguments_thing : {'xc': '20', 'yc': '10', 'r': '10'}
-bullshit: {'xc': '20', 'yc': '10', 'r': '10'}
-bullshit: {'xc': '20', 'yc': '10', 'r': '10'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['circle0']
-objects after appending new_object: ['circle0']
-global_objects after appending new_object: ['circle0']
-[92mCreated new object.[0m
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-self.yc : 10
-result: None
-Command string: point x=20 y=10
-fewfeewfewfewf
-arguments: ['x=20', 'y=10']
-object_name: point
-{'x': '20', 'y': '10'}
-*arguments_thing : {'x': '20', 'y': '10'}
-bullshit: {'x': '20', 'y': '10'}
-bullshit: {'x': '20', 'y': '10'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mycircle']
-global_objects at the start: ['mycircle']
-objects after creation of new_object : ['mycircle']
-gregregregrr
-global_objects at the start: ['mycircle', 'point0']
-objects after appending new_object: ['mycircle', 'point0']
-global_objects after appending new_object: ['mycircle', 'point0']
-Command string: line a=4 b=-3 c=50
-fewfeewfewfewf
-objects at the start: ['mycircle', 'point0']
-arguments: ['a=4', 'b=-3', 'c=50']
-object_name: line
-{'a': '4', 'b': '-3', 'c': '50'}
-*arguments_thing : {'a': '4', 'b': '-3', 'c': '50'}
-bullshit: {'a': '4', 'b': '-3', 'c': '50'}
-bullshit: {'a': '4', 'b': '-3', 'c': '50'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mycircle', 'point0']
-global_objects at the start: ['mycircle', 'point0']
-objects after creation of new_object : ['mycircle', 'point0']
-gregregregrr
-global_objects at the start: ['mycircle', 'point0', 'line0']
-objects after appending new_object: ['mycircle', 'point0', 'line0']
-global_objects after appending new_object: ['mycircle', 'point0', 'line0']
-objects at the end: ['mycircle', 'point0', 'line0']
-[92mCreated new object.[0m
-Command string: line0.name = linething
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linething
-result: None
-Command string: oof := mindistpointobjdot linething point0
-poopooshit
-fewfeewfewfewf
-stuff == ['linething', 'point0']
-command_string: mindistpointobjdot linething point0
-new_command_string == mindistpointobjdot linething point0
-
-
-
-
-circle xc=20 yc=10 r=10
-circle0.name = mycircle
-point x=20 y=10
-line a=4 b=-3 c=50
-line0.name = linething
-oof := mindistpointobjdot linething point0
-point [oof]
-po
-quit
-
-
-
-
-
-
-
-
-
-Running subcommand: mindistpointobjdot
-
-
-
-
-
-name_str: linething
-['mycircle', 'point0', 'linething']
----------------------------
-mycircle
-point0
-linething
----------------------------
-obj.name == mycircle
-obj.name == point0
-name_str: point0
-['mycircle', 'point0', 'linething']
----------------------------
-mycircle
-point0
-linething
----------------------------
-obj.name == mycircle
-oof
-oof22
-object_equation : [Eq(4*x - 3*y + 50, 0)]
-[4*x - 3*y + 0 + 50]
-[x]
-[4*x - 3*y + 0 + 50]
-[x]
-[[4*x - 3*y + 0 + 50]]
-[3*y/4 - 25/2, x]
-Matrix([[4, 3*y - 50]])
-[4*x - 3*y + 0 + 50]
-[y]
-[4*x - 3*y + 0 + 50]
-[y]
-[[4*x - 3*y + 0 + 50]]
-[4*x/3 + 50/3, y]
-Matrix([[3, 4*x + 50]])
-sol_x : {x: 3*y/4 - 25/2}
-sol_y : {y: 4*x/3 + 50/3}
-substitution: None
-thing: {x: 3*y/4 - 25/2, y: 4*x/3 + 50/3}
-bullshit ooof :::: sqrt((x-20)**2+(x-10)**2)
-distance_function : sqrt((x - 20)**2 + (x - 10)**2)
-Substituted distance function: sqrt((x - 20)**2 + (x - 10)**2)
-f: sqrt((x - 20)**2 + (x - 10)**2)
-solution: 5*sqrt(2)
-distance_function : sqrt((x - 20)**2 + (x - 10)**2)
-Minimum distance: 5*sqrt(2)
-name_str: point0
-['mycircle', 'point0', 'linething']
----------------------------
-mycircle
-point0
-linething
----------------------------
-obj.name == mycircle
-name_str: linething
-['mycircle', 'point0', 'linething']
----------------------------
-mycircle
-point0
-linething
----------------------------
-obj.name == mycircle
-obj.name == point0
-oof
-oof22
-radiuses : 5*sqrt(2)
-Returning this: (x-20)**2+(y-10)**2=(5*sqrt(2))**2
-circle_equation : [Eq((x - 20)**2 + (y - 10)**2, 50)]
-all equations: [Eq(4*x - 3*y + 50, 0), Eq((x - 20)**2 + (y - 10)**2, 50)]
-[4*x - 3*y + 0 + 50, (x - 20)**2 + (y - 10)**2 - 50]
-[x, y]
-[4*x - 3*y + 0 + 50, (x - 20)**2 + (y - 10)**2 - 50]
-[x, y]
-[[4*x - 3*y + 0 + 50, (x - 20)**2 + (y - 10)**2 - 50]]
-[-50, 4*x - 3*y]
-[50, (x - 20)**2 + (y - 10)**2]
-[Poly(4*x - 3*y + 50, x, y, domain='ZZ'), Poly(x**2 - 40*x + y**2 - 20*y + 450, x, y, domain='ZZ')]
-[Poly(4*x - 3*y + 50, x, y, domain='ZZ'), Poly(x**2 - 40*x + y**2 - 20*y + 450, x, y, domain='ZZ')]
-Result: [(4 - 3*sqrt(14)*I, 22 - 4*sqrt(14)*I), (4 + 3*sqrt(14)*I, 22 + 4*sqrt(14)*I)]
-Resulting dict: {'x': 4 - 3*sqrt(14)*I, 'y': 22 - 4*sqrt(14)*I}
-oofstring1: 4 - 3*sqrt(14)*I
-oofstring2: 4 - 3*sqrt(14)*I
-oofstring1 after: 4-3*sqrt(14)*I
-oofstring2 after: 4-3*sqrt(14)*I
-final_dict: {'x': '4-3*sqrt(14)*I', 'y': '4-3*sqrt(14)*I'}
-
-
-
-
-Returned from the assignment command:
-var_values : {'x': 4 - 3*sqrt(14)*I, 'y': 22 - 4*sqrt(14)*I}
-var_values.keys()dict_keys(['x', 'y'])
-['x', 'y']
-['4 - 3*sqrt(14)*I', '22 - 4*sqrt(14)*I']
-Command string: point [oof]
-fewfeewfewfewf
-str(var_values) == {'x': 4 - 3*sqrt(14)*I, 'y': 22 - 4*sqrt(14)*I}
-start == None
-end == None
-var_values final: {'x': 4 - 3*sqrt(14)*I, 'y': 22 - 4*sqrt(14)*I}
-arguments: ['x=4', '-', '3*sqrt(14)*I', 'y=22', '-', '4*sqrt(14)*I']
-object_name: point
diff --git a/outputthing.txt b/outputthing.txt
deleted file mode 100644
index e408ac8..0000000
--- a/outputthing.txt
+++ /dev/null
@@ -1,156 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file smoketestmindistance.txt.
-Command string: 
-Command string: 
-Command string: point x=5 y=3
-fewfeewfewfewf
-arguments: ['x=5', 'y=3']
-object_name: point
-{'x': '5', 'y': '3'}
-*arguments_thing : {'x': '5', 'y': '3'}
-bullshit: {'x': '5', 'y': '3'}
-bullshit: {'x': '5', 'y': '3'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['point0']
-objects after appending new_object: ['point0']
-global_objects after appending new_object: ['point0']
-Command string: line a=4 b=-3 c=50
-fewfeewfewfewf
-objects at the start: ['point0']
-arguments: ['a=4', 'b=-3', 'c=50']
-object_name: line
-{'a': '4', 'b': '-3', 'c': '50'}
-*arguments_thing : {'a': '4', 'b': '-3', 'c': '50'}
-bullshit: {'a': '4', 'b': '-3', 'c': '50'}
-bullshit: {'a': '4', 'b': '-3', 'c': '50'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['point0']
-global_objects at the start: ['point0']
-objects after creation of new_object : ['point0']
-gregregregrr
-global_objects at the start: ['point0', 'line0']
-objects after appending new_object: ['point0', 'line0']
-global_objects after appending new_object: ['point0', 'line0']
-objects at the end: ['point0', 'line0']
-[92mCreated new object.[0m
-Command string: line0.name = linething
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linething
-result: None
-Command string: mindistpointobjdot linething point0
-fewfeewfewfewf
-name_str: linething
-['point0', 'linething']
----------------------------
-point0
-linething
----------------------------
-obj.name == point0
-name_str: point0
-['point0', 'linething']
----------------------------
-point0
-linething
----------------------------
-dot_thing: =======================
-Type: point
-x = 5
-y = 3
-name = point0
-=======================
-
-object_thing: =======================
-Type: line
-a = 4
-b = -3
-c = 50
-name = linething
-=======================
-		
-oof
-oof22
-object_equation : [Eq(4*x - 3*y + 50, 0)]
-[4*x - 3*y + 0 + 50]
-[x]
-[4*x - 3*y + 0 + 50]
-[x]
-[[4*x - 3*y + 0 + 50]]
-[3*y/4 - 25/2, x]
-Matrix([[4, 3*y - 50]])
-[4*x - 3*y + 0 + 50]
-[y]
-[4*x - 3*y + 0 + 50]
-[y]
-[[4*x - 3*y + 0 + 50]]
-[4*x/3 + 50/3, y]
-Matrix([[3, 4*x + 50]])
-sol_x : {x: 3*y/4 - 25/2}
-sol_y : {y: 4*x/3 + 50/3}
-substitution: {x: 3*y/4 - 25/2, y: 4*x/3 + 50/3}
-thing: {x: 3*y/4 - 25/2, y: 4*x/3 + 50/3}
-bullshit ooof :::: sqrt((x-5)**2+(y-3)**2)
-distance_function : sqrt((x - 5)**2 + (y - 3)**2)
-Substituted distance function: sqrt((x - 5)**2 + (4*x/3 + 41/3)**2)
-f: sqrt((x - 5)**2 + (4*x/3 + 41/3)**2)
-solution: 61/5
-distance_function : sqrt((x - 5)**2 + (4*x/3 + 41/3)**2)
-Minimum distance: 61/5
-name_str: point0
-['point0', 'linething']
----------------------------
-point0
-linething
----------------------------
-name_str: linething
-['point0', 'linething']
----------------------------
-point0
-linething
----------------------------
-obj.name == point0
-oof
-oof22
-radiuses : 61/5
-Returning this: (x-5)**2+(y-3)**2=(61/5)**2
-circle_equation : [Eq((x - 5)**2 + (y - 3)**2, 3721/25)]
-all equations: [Eq(4*x - 3*y + 50, 0), Eq((x - 5)**2 + (y - 3)**2, 3721/25)]
-[4*x - 3*y + 0 + 50, (x - 5)**2 + (y - 3)**2 - 3721/25]
-[x, y]
-[4*x - 3*y + 0 + 50, (x - 5)**2 + (y - 3)**2 - 3721/25]
-[x, y]
-[[4*x - 3*y + 0 + 50, (x - 5)**2 + (y - 3)**2 - 3721/25]]
-[-50, 4*x - 3*y]
-[3721/25, (x - 5)**2 + (y - 3)**2]
-[Poly(4*x - 3*y + 50, x, y, domain='ZZ'), Poly(25*x**2 - 250*x + 25*y**2 - 150*y - 2871, x, y, domain='ZZ')]
-[Poly(4*x - 3*y + 50, x, y, domain='ZZ'), Poly(25*x**2 - 250*x + 25*y**2 - 150*y - 2871, x, y, domain='ZZ')]
-Result: [(-119/25, 258/25)]
-Resulting dict: {'x': -119/25, 'y': 258/25}
-oofstring1: -119/25
-oofstring2: 258/25
-oofstring1 after: -119/25
-oofstring2 after: 258/25
-final_dict: {'x': '-119/25', 'y': '258/25'}
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git a/pointtest.txt b/pointtest.txt
deleted file mode 100644
index 19c22da..0000000
--- a/pointtest.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-line
-line0.name = myline
-point
-point0.name = mypoint1
-point
-point0.name = mypoint2
-objects
-mypoint1.x = 1
-mypoint1.y = 2
-mypoint2.x = 3
-mypoint2.y = 4
-myline.set_values_two_points mypoint1 mypoint2
diff --git a/poopooshit.txt b/poopooshit.txt
deleted file mode 100644
index f11fa4f..0000000
--- a/poopooshit.txt
+++ /dev/null
@@ -1,243 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file ./tests/check_intersection_triangle_circle.txt.
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['triangle0']
-objects after appending new_object: ['triangle0']
-global_objects after appending new_object: ['triangle0']
-Command result: 0
-Command string: circle xc=0.8 yc=0.4 r=0.3
-fewfeewfewfewf
-arguments: ['xc=0.8', 'yc=0.4', 'r=0.3']
-object_name: circle
-{'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-*arguments_thing : {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['triangle0']
-global_objects at the start: ['triangle0']
-objects after creation of new_object : ['triangle0']
-gregregregrr
-global_objects at the start: ['triangle0', 'circle0']
-objects after appending new_object: ['triangle0', 'circle0']
-global_objects after appending new_object: ['triangle0', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 circle0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'circle0']
-obj_name1 : triangle0
-obj_name2 : circle0
-name_str: triangle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-name_str: circle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7f9d8abc9100>
-obj2: =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f9d8abc9100>
-object2 : =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.circle'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-Circle equation bullshit: 
-((x)-(0.8))**2+((y)-(0.4))**2=(0.3)**2
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-Final plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, 5*x - 30*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 0.648031893339682, 'y': 0.141338648889947}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 1.02764378233599, 'y': 0.204607297055999}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, -3*x + 2*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.523076923076923, 'y': 0.284615384615385}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.800000000000000, 'y': 0.700000000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[1, x]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-poopoo
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.176393202250021}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.623606797749979}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}][0m
-Command result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git a/ppppppppp.py b/ppppppppp.py
deleted file mode 100644
index 4e944c2..0000000
--- a/ppppppppp.py
+++ /dev/null
@@ -1,1679 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	#x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	#y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	#x_is_var = False
-
-	#solutions = sympy.solve(object_equations,"x,y")
-	sol_x = sympy.solve(object_equations,"x")
-	sol_y = sympy.solve(object_equations,"y")
-
-
-	print("sol_x : "+str(sol_x))
-	print("sol_y : "+str(sol_y))
-	if isinstance(sol_x, list):
-		sol_x = sol_x[0]
-		sol_y = sol_y[0]
-
-
-	thing = sol_x
-	substitution = thing.update(sol_y)
-	print("substitution: "+str(substitution))
-	print("thing: "+str(thing))
-
-	#print("Solutions: "+str(solutions))
-
-
-
-	#y0 = y0[list(y0.keys())[0]]
-
-	x = Symbol('x')
-	y = Symbol('x')
-	distance_function = distance_thing(x,y,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-	distance_function = distance_function.subs(thing)
-	print("Substituted distance function: "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-	
-	print("f: "+str(f))
-	if not maximumthing:
-
-		solution = minimum(f, x)
-	else:
-		solution = maximum(f, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/problems.txt b/problems.txt
deleted file mode 100644
index 010adf4..0000000
--- a/problems.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-
-363 359
-
diff --git a/qqqqqqqqqq.py b/qqqqqqqqqq.py
deleted file mode 100644
index 660047a..0000000
--- a/qqqqqqqqqq.py
+++ /dev/null
@@ -1,887 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects"]
-
-object_types = ["line", "circle", "points"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-	def __init__(self, x=None, y=None, vector=None):
-		if vector != None:
-			self.vector = vector
-			self.x=vector.item(0)
-			self.y=vector.item(1)
-		elif x==None and y==None:
-			warn("Warning. Uninitialized point.")
-			return
-		else:
-			self.vector = np.array([[x],[y]])
-			self.x = x
-			self.y = y
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-	
-		
-
-def get_object_by_name(name_str):
-
-	count = 0
-	obj = global_objects[0]
-	while obj.name != name_str and count != len(global_objects):
-		obj = global_objects[count]
-		count += 1
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(point1, point2):
-
-		# get vector from point1 to point2
-
-		from1to2 = -1*point1+point2
-
-		self.set_values_point_line(point1, from1to2)
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(method_string, command):
-		# global_objects
-		print("bullshitrgregreg")
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		for i in range(self.num_args[self.num_args.index(method_string)]):
-			# get the arguments
-
-			if self.method_arg_types[correct_method_index] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-
-	for equation1, equation2 in zip(equations1, equations2):
-
-
-
-
-		temp_var_x = Symbol("tempvarx")
-		temp_var_y = Symbol("tempvary")
-
-		substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-		substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-		print("substitute_first : " + str(substitute_first))
-
-		equation1 = equation1.subs(substitute_first)
-
-		equation2 = equation2.subs(substitute_second)
-
-		print("-----------")
-		print(equation1)
-		print(equation2)
-		print("-----------")
-		print(temp_var_x)
-		print(temp_var_y)
-
-		result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-		print("result: "+str(result))
-		results.append(result)
-	return results
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-
-	print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	obj.run_method_on_self(method_str, command_string)
-	#function = getattr(obj, method_str, None)
-
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle"]
-	min_arg_lengths = [0,0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0,3]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" "):
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/rjkgnjkjkrgrenjkgnrjkrgnjkregjknger.py b/rjkgnjkjkrgrenjkgnrjkrgnjkregjknger.py
deleted file mode 100644
index c67362e..0000000
--- a/rjkgnjkjkrgrenjkgnrjkrgnjkregjknger.py
+++ /dev/null
@@ -1,1691 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-import random
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values or expressions
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	if len(results) == 1:
-		
-		point = results[0]
-		x = point[0]
-		y = point[1]
-		return {"x":x, "y":y}
-
-
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:] # get rid of the initial command
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-	print("stuff == "+str(stuff))
-	print("command_string: "+str(command_string))
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	#object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-
-	object_equations = object.get_equations()
-
-
-	print("object_equation : "+str(object_equations))
-	y0 = sympy.solve(object_equations, 'y')  # make it of the form: y=...
-	x_is_var = False
-	if isinstance(y0, list) and len(y0) == 1:
-		print("y0: "+str(y0))
-		y0 = y0[0]
-
-		x_is_var = True
-
-	#print("y0 : "+str(y0))
-	#print("y0.keys() == "+str(y0.keys()))
-	
-	
-	if not x_is_var:
-		print("object_equations: "+str(object_equations))
-		x = sympy.Symbol('x')
-		y = sympy.Symbol('y')
-		xsol = sympy.solve(object_equations, 'x')
-		print("xsol: "+str(xsol))
-		if isinstance(x0, list):
-
-			x0 = xsol[0]
-			x0 = x0[x]
-
-		if isinstance(x0, list):
-			y0 = y0[0]
-			y0 = y0[y]
-		#print("y0: "+str(y0))
-		#print("x0 thing poopoo: " + str(x0))
-
-		#print("y0[x]: "+str(y0[y]))
-		#print("x0[y] thing poopoo: " + str(x0[x]))
-
-		
-		
-
-		distance_function = distance_thing(x0,y0,x1,y1)
-		return distance_function
-
-	y0 = y0[list(y0.keys())[0]]
-
-	
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-	resulting_dict = {'x':result[0][0], 'y':result[0][1]}
-
-	return resulting_dict
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(object_name).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = solve(equation_list, ('x', 'y'))
-	print("intersection_points == "+str(intersection_points))
-	if len(intersection_points) < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = [intersection_points[0][0], intersection_points[1][0]]
-	print("thingoof intersection_x_values ==" + str())
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-	print("functions_in_y_format == "+str(functions_in_y_format))
-
-	if (len(functions_in_y_format[0])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[0]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[0] = [functions_in_y_format[0][index]]
-
-
-
-
-
-	if (len(functions_in_y_format[1])) > 1:
-		print("Please select one of these graphs: ")
-		count = 0
-		for thing in functions_in_y_format[1]:
-			print(str(count) + " : "+str(thing))
-			count+=1 
-		index = int(input(">>"))
-
-		functions_in_y_format[1] = [functions_in_y_format[1][index]]
-
-
-
-	if functions_in_y_format[0][0].subs({'x':check_value}) > functions_in_y_format[1][0].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0][0]
-		smaller_fun = functions_in_y_format[1][0]
-	else:
-		bigger_function = functions_in_y_format[1][0]
-		smaller_fun = functions_in_y_format[0][0]
-
-
-	print("bigger function: "+str(bigger_function))
-	print("smaller_fun : " + str(smaller_fun))
-
-	#difference_function = parse_expr(bigger_function) - parse_expr(smaller_fun)
-
-	difference_function = bigger_function - smaller_fun
-
-
-	print("intersection_x_values[0] == "+str(intersection_x_values[0]))
-	print("intersection_x_values[1] == "+str(intersection_x_values[1]))
-
-
-	resulting_area = integrate(difference_function, ('x', intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + bcolors.ENDC)
-
-
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate", "area_between_intersections"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command, area_between_intersections]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/samplething.txt b/samplething.txt
deleted file mode 100644
index 573541a..0000000
--- a/samplething.txt
+++ /dev/null
@@ -1 +0,0 @@
-0
diff --git a/shit.py b/shit.py
deleted file mode 100644
index f96b101..0000000
--- a/shit.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from sympy import *
-
-x = Symbol('x')
-y = Symbol('y')
-eq1 = Eq(2*x+3*y,5)
-eq2 = Eq(5*x+11*y,10,x>10)
-solution = solve([eq1, eq2], [x,y])
-print(solution)
diff --git a/shitoof.txt b/shitoof.txt
deleted file mode 100644
index c52b01c..0000000
--- a/shitoof.txt
+++ /dev/null
@@ -1,129 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['point0']
-objects after appending new_object: ['point0']
-global_objects after appending new_object: ['point0']
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['mypoint']
-global_objects at the start: ['mypoint']
-objects after creation of new_object : ['mypoint']
-gregregregrr
-global_objects at the start: ['mypoint', 'circle0']
-objects after appending new_object: ['mypoint', 'circle0']
-global_objects after appending new_object: ['mypoint', 'circle0']
-[92mCreated new object.[0m
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-name_str: mycircle
-['mypoint', 'mycircle']
----------------------------
-mypoint
-mycircle
----------------------------
-obj.name == mypoint
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: <__main__.circle object at 0x7f9644ad1130>
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : <__main__.circle object at 0x7f9644ad1130>
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-oof
-oof22
-bullshit
-equation : Eq(x, 7.0)
-"x"+str(object1.var_count) == x0
-equation : Eq(y, 2.0)
-"x"+str(object1.var_count) == x0
-substituted_equations
-Eq(x, 7.0)
-Eq(y, 2.0)
-Eq((x - xc0)**2 + (y - yc0)**2, r0**2)
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [][0m
-[94m>>> [0m
\ No newline at end of file
diff --git a/shitthing.txt b/shitthing.txt
deleted file mode 100644
index 181ed47..0000000
--- a/shitthing.txt
+++ /dev/null
@@ -1,229 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file triangleproblempart2.txt.
-Command string: line a=1.455 b=-1 c=-517.0
-fewfeewfewfewf
-objects at the start: []
-{'a': '1.455', 'b': '-1', 'c': '-517.0'}
-*arguments_thing : {'a': '1.455', 'b': '-1', 'c': '-517.0'}
-bullshit: {'a': '1.455', 'b': '-1', 'c': '-517.0'}
-bullshit: {'a': '1.455', 'b': '-1', 'c': '-517.0'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command string: line0.name = halwayline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: halwayline
-result: None
-Command string: line
-fewfeewfewfewf
-objects at the start: ['halwayline']
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['halwayline']
-global_objects at the start: ['halwayline']
-objects after creation of new_object : ['halwayline']
-gregregregrr
-global_objects at the start: ['halwayline', 'line0']
-objects after appending new_object: ['halwayline', 'line0']
-global_objects after appending new_object: ['halwayline', 'line0']
-objects at the end: ['halwayline', 'line0']
-[92mCreated new object.[0m
-Command string: line0.name = side
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: side
-result: None
-Command string: point x=0 y=0
-fewfeewfewfewf
-{'x': '0', 'y': '0'}
-*arguments_thing : {'x': '0', 'y': '0'}
-bullshit: {'x': '0', 'y': '0'}
-bullshit: {'x': '0', 'y': '0'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['halwayline', 'side']
-global_objects at the start: ['halwayline', 'side']
-objects after creation of new_object : ['halwayline', 'side']
-gregregregrr
-global_objects at the start: ['halwayline', 'side', 'point0']
-objects after appending new_object: ['halwayline', 'side', 'point0']
-global_objects after appending new_object: ['halwayline', 'side', 'point0']
-Command string: point x=556.202247191011 y=520.8484042595016
-fewfeewfewfewf
-{'x': '556.202247191011', 'y': '520.8484042595016'}
-*arguments_thing : {'x': '556.202247191011', 'y': '520.8484042595016'}
-bullshit: {'x': '556.202247191011', 'y': '520.8484042595016'}
-bullshit: {'x': '556.202247191011', 'y': '520.8484042595016'}
-the_object.name == point1
-setting parameter x to this: x1
-the_object.name == point1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['halwayline', 'side', 'point0']
-global_objects at the start: ['halwayline', 'side', 'point0']
-objects after creation of new_object : ['halwayline', 'side', 'point0']
-gregregregrr
-global_objects at the start: ['halwayline', 'side', 'point0', 'point1']
-objects after appending new_object: ['halwayline', 'side', 'point0', 'point1']
-global_objects after appending new_object: ['halwayline', 'side', 'point0', 'point1']
-Command string: side.set_values_two_points point0 point1
-thing
-bullshitrgregreg
-command: side.set_values_two_points point0 point1
-self.method_arg_types : [['point', 'point'], ['point', 'point'], [], []]
-name_str: point0
-['halwayline', 'side', 'point0', 'point1']
----------------------------
-halwayline
-side
-point0
-point1
----------------------------
-obj.name == halwayline
-obj.name == side
-self.method_arg_types : [['point', 'point'], ['point', 'point'], [], []]
-name_str: point1
-['halwayline', 'side', 'point0', 'point1']
----------------------------
-halwayline
-side
-point0
-point1
----------------------------
-obj.name == halwayline
-obj.name == side
-obj.name == point0
-==========================================
-point1.x : 0 point1.y: 0
-point2.x : 556.202247191011 point2.y: 520.8484042595016
-==========================================
--1*point1.x+point2.x == 556.202247191011
--1*point1.x == 
-type(point1.x) == <class 'str'>
-xv: 556.202247191011
-yv: 520.8484042595016
-0000000
-yv: 520.8484042595016
-x0: 0.0
-xv: 556.202247191011
-y0: 0.0
-string_oof_1 : -(520.8484042595016/(0.0*520.8484042595016-556.202247191011*0.0))
-string_oof_2 == 556.202247191011/(0.0*520.8484042595016-556.202247191011*0.0)
-self.a ==zoo
-self.b ==zoo
-result: None
-Command string: intersect side halwayline
-fewfeewfewfewf
-Args : ['intersect', 'side', 'halwayline']
-obj_name1 : side
-obj_name2 : halwayline
-name_str: side
-['halwayline', 'side', 'point0', 'point1']
----------------------------
-halwayline
-side
-point0
-point1
----------------------------
-obj.name == halwayline
-name_str: halwayline
-['halwayline', 'side', 'point0', 'point1']
----------------------------
-halwayline
-side
-point0
-point1
----------------------------
-poopooo
-obj1: =======================
-Type: line
-a = zoo
-b = zoo
-c = 1
-name = side
-=======================
-		
-obj2: =======================
-Type: line
-a = 1.455
-b = -1
-c = -517.0
-name = halwayline
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = zoo
-b = zoo
-c = 1
-name = side
-=======================
-		
-object2 : =======================
-Type: line
-a = 1.455
-b = -1
-c = -517.0
-name = halwayline
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(zoo*x + zoo*y + 1, 0), Eq(1.455*x - y - 517.0, 0)]
-[zoo*x + zoo*y + 0 + 1, 291*x/200 - y - 517]
-[x, y]
-[zoo*x + zoo*y + 0 + 1, 291*x/200 - y - 517]
-[x, y]
-[[zoo*x + zoo*y + 0 + 1, 291*x/200 - y - 517]]
-[-1, zoo*x + zoo*y]
-[517, 291*x/200 - y]
-Matrix([[zoo, zoo, -1], [291, -200, 103400]])
-result: {x: nan, y: nan}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: nan, y: nan}[0m
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git "a/sivu142teht\303\244v\303\24415.txt" "b/sivu142teht\303\244v\303\24415.txt"
deleted file mode 100644
index 5c9a47c..0000000
--- "a/sivu142teht\303\244v\303\24415.txt"
+++ /dev/null
@@ -1,9 +0,0 @@
-
-
-point x=5 y=3
-line a=4 b=-3 c=50
-line0.name = linething
-oof := mindistpointobjdot linething point0
-point [oof]
-point1
-quit
diff --git a/smoketestmindistance.txt b/smoketestmindistance.txt
deleted file mode 100644
index 953df71..0000000
--- a/smoketestmindistance.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-
-
-point x=5 y=3
-line a=4 b=-3 c=50
-line0.name = linething
-mindistpointobjdot linething point0
-quit
diff --git a/solve_problem.txt b/solve_problem.txt
deleted file mode 100644
index b2e67a9..0000000
--- a/solve_problem.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-circle
-circle0.name = mycircle1
-mycircle1.xc = 0
-mycircle1.yc = 0
-mycircle1.r = 2
-
-circle
-circle0.name = mycircle2
-mycircle2.xc = 4/2
-mycircle2.yc = 0
-mycircle2.r = 2
-
-intersect mycircle1 mycircle2
diff --git a/solve_problem2.txt b/solve_problem2.txt
deleted file mode 100644
index 4eb36ef..0000000
--- a/solve_problem2.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-circle
-circle0.name = mycircle1
-mycircle1.xc = 0
-mycircle1.yc = 0
-mycircle1.r = 1
-point x=((1+2+0)/3) y=(sqrt(3)/3)
-point0.name = mypoint
-maxdistobjdot mycircle1 mypoint
-quit
diff --git a/stuff.txt b/stuff.txt
deleted file mode 100644
index 1739a2e..0000000
--- a/stuff.txt
+++ /dev/null
@@ -1,199 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file stuff/triangle.txt.
-Command string: 
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['triangle0']
-objects after appending new_object: ['triangle0']
-global_objects after appending new_object: ['triangle0']
-Command result: 0
-Command string: line a=0.1 b=1 c=-0.5
-fewfeewfewfewf
-objects at the start: ['triangle0']
-arguments: ['a=0.1', 'b=1', 'c=-0.5']
-object_name: line
-{'a': '0.1', 'b': '1', 'c': '-0.5'}
-*arguments_thing : {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['triangle0']
-global_objects at the start: ['triangle0']
-objects after creation of new_object : ['triangle0']
-gregregregrr
-global_objects at the start: ['triangle0', 'line0']
-objects after appending new_object: ['triangle0', 'line0']
-global_objects after appending new_object: ['triangle0', 'line0']
-objects at the end: ['triangle0', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 line0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'line0']
-obj_name1 : triangle0
-obj_name2 : line0
-name_str: triangle0
-['triangle0', 'line0']
----------------------------
-triangle0
-line0
----------------------------
-name_str: line0
-['triangle0', 'line0']
----------------------------
-triangle0
-line0
----------------------------
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7f3207c47100>
-obj2: =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f3207c47100>
-object2 : =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.line'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq(0.1*x + y - 0.5, 0)]
-Final plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[[5*x - 30*y + 1, x/10 + y - 1/2]]
-[-1, 5*x - 30*y]
-[1/2, x/10 + y]
-Matrix([[5, -30, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: {x: 1.75000000000000, y: 0.325000000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {x: 1.75000000000000, y: 0.325000000000000}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[[-3*x + 2*y + 1, x/10 + y - 1/2]]
-[-1, -3*x + 2*y]
-[1/2, x/10 + y]
-Matrix([[-3, 2, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: {x: 0.625000000000000, y: 0.437500000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {x: 0.625000000000000, y: 0.437500000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[[1 - x, x/10 + y - 1/2]]
-[1, x]
-[1/2, x/10 + y]
-Matrix([[1, 0, 1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: {x: 1.00000000000000, y: 0.400000000000000}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {x: 1.00000000000000, y: 0.400000000000000}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}][0m
-Command result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git a/stuff/triangle.txt b/stuff/triangle.txt
deleted file mode 100644
index ee4bb73..0000000
--- a/stuff/triangle.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-
-triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-line a=0.1 b=1 c=-0.5
-intersect triangle0 line0
-quit
-
-#[{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
\ No newline at end of file
diff --git a/stuff2.txt b/stuff2.txt
deleted file mode 100644
index 3145bd6..0000000
--- a/stuff2.txt
+++ /dev/null
@@ -1,201 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file ./tests/check_intersection_triangle_circle.txt.
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['triangle0']
-objects after appending new_object: ['triangle0']
-global_objects after appending new_object: ['triangle0']
-Command result: 0
-Command string: circle xc=0.8 yc=0.4 r=0.3
-fewfeewfewfewf
-arguments: ['xc=0.8', 'yc=0.4', 'r=0.3']
-object_name: circle
-{'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-*arguments_thing : {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['triangle0']
-global_objects at the start: ['triangle0']
-objects after creation of new_object : ['triangle0']
-gregregregrr
-global_objects at the start: ['triangle0', 'circle0']
-objects after appending new_object: ['triangle0', 'circle0']
-global_objects after appending new_object: ['triangle0', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 circle0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'circle0']
-obj_name1 : triangle0
-obj_name2 : circle0
-name_str: triangle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-name_str: circle0
-['triangle0', 'circle0']
----------------------------
-triangle0
-circle0
----------------------------
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7f7168135100>
-obj2: =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f7168135100>
-object2 : =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.circle'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-Circle equation bullshit: 
-((x)-(0.8))**2+((y)-(0.4))**2=(0.3)**2
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-Final plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, 5*x - 30*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, -3*x + 2*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[1, x]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [[(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)], [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)], [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]][0m
-Command result: [[(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)], [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)], [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]]
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
diff --git a/stuffthing.txt b/stuffthing.txt
deleted file mode 100644
index 8558889..0000000
--- a/stuffthing.txt
+++ /dev/null
@@ -1,2365 +0,0 @@
-Running test check_var_assignment_to_function_result.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_assignment_to_function_result.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1']
-global_objects at the start: ['myline1']
-objects after creation of new_object : ['myline1']
-gregregregrr
-global_objects at the start: ['myline1', 'line0']
-objects after appending new_object: ['myline1', 'line0']
-global_objects after appending new_object: ['myline1', 'line0']
-objects at the end: ['myline1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == None
-end == None
-var_values final: {x: 1, y: -2}
-arguments: ['x=1', 'y=-2']
-object_name: point
-{'x': '1', 'y': '-2'}
-*arguments_thing : {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2']
-global_objects at the start: ['myline1', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = -2
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = -2name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[92mTestsuite tests/check_var_assignment_to_function_result.txt passed![0m
-Running test check_line_intersect.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_intersect.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line1
-setting parameter a to this: a1
-the_object.name == line1
-setting parameter b to this: b1
-the_object.name == line1
-setting parameter c to this: c1
-the_object.name == line1
-setting parameter x to this: x1
-the_object.name == line1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'line0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'line0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect line0 line1
-fewfeewfewfewf
-Args : ['intersect', 'line0', 'line1']
-obj_name1 : line0
-obj_name2 : line1
-name_str: line0
-['myline1', 'myline2', 'mypoint', 'line0', 'line1']
----------------------------
-myline1
-myline2
-mypoint
-line0
-line1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-name_str: line1
-['myline1', 'myline2', 'mypoint', 'line0', 'line1']
----------------------------
-myline1
-myline2
-mypoint
-line0
-line1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == line0
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Command result: {x: 1, y: -2}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {x: 1, y: -2}
-Expected final result: {x: 1, y: -2}
-command_result: {x: 1, y: -2}
-expected_result: {x: 1, y: -2}
-[92mTestsuite tests/check_line_intersect.txt passed![0m
-Running test check_var_subsequences.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_subsequences.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line2
-setting parameter a to this: a2
-the_object.name == line2
-setting parameter b to this: b2
-the_object.name == line2
-setting parameter c to this: c2
-the_object.name == line2
-setting parameter x to this: x2
-the_object.name == line2
-setting parameter y to this: y2
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar][0:1]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == 0
-end == 1
-abcdefg
-l == (x,)
-var_values final: {x: 1}
-arguments: ['x=1']
-object_name: point
-{'x': '1'}
-*arguments_thing : {'x': '1'}
-bullshit: {'x': '1'}
-bullshit: {'x': '1'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = -2
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = -2name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[92mTestsuite tests/check_var_subsequences.txt passed![0m
-Running test check_max_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_max_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: maxdistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: oo
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Maximum distance: oo
-Command result: oo
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: oo
-Expected final result: oo
-command_result: oo
-expected_result: oo
-[92mTestsuite tests/check_max_output_dot_line.txt passed![0m
-Running test check_intersection_triangle_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_intersection_triangle_circle.txt.
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-Command result: 0
-Command string: circle xc=0.8 yc=0.4 r=0.3
-fewfeewfewfewf
-arguments: ['xc=0.8', 'yc=0.4', 'r=0.3']
-object_name: circle
-{'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-*arguments_thing : {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 circle0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'circle0']
-obj_name1 : triangle0
-obj_name2 : circle0
-name_str: triangle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-circle0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-name_str: circle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-circle0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7f142df0cc10>
-obj2: =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f142df0cc10>
-object2 : =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.circle'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-Circle equation bullshit: 
-((x)-(0.8))**2+((y)-(0.4))**2=(0.3)**2
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-Final plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, 5*x - 30*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 0.648031893339682, 'y': 0.141338648889947}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 1.02764378233599, 'y': 0.204607297055999}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, -3*x + 2*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.523076923076923, 'y': 0.284615384615385}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.800000000000000, 'y': 0.700000000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[1, x]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-poopoo
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.176393202250021}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.623606797749979}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}][0m
-Command result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Expected final result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-command_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-expected_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-[92mTestsuite tests/check_intersection_triangle_circle.txt passed![0m
-Running test check_integral.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_integral.txt.
-Command string: integrate y=x**2 x 1 3
-fewfeewfewfewf
-selected_expr: Eq(y, x**2)
-[-x**2 + y]
-[y]
-ok so it is a bare function and not a system of equations
-y_function: [x**2]
-[33mResult: 26/3[0m
-Command result: 26/3
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 26/3
-Expected final result: 26/3
-command_result: 26/3
-expected_result: 26/3
-[92mTestsuite tests/check_integral.txt passed![0m
-Running test check_point_on_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-arguments: []
-object_name: circle
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle1
-setting parameter xc to this: xc1
-the_object.name == circle1
-setting parameter yc to this: yc1
-the_object.name == circle1
-setting parameter r to this: r1
-the_object.name == circle1
-setting parameter x to this: x1
-the_object.name == circle1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-[92mCreated new object.[0m
-Command result: 0
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-self.yc : 0.4
-result: None
-Command string: mycircle.xc = 10
-thing
-==================================================================================
-Setting property : xc
-On object: mycircle
-selected_property: xc
-value: 10
-self.yc : 0.4
-result: None
-Command string: mycircle.yc = 2
-thing
-==================================================================================
-Setting property : yc
-On object: mycircle
-selected_property: yc
-value: 2
-self.yc : 0.4
-result: None
-Command string: mycircle.r = 3
-thing
-==================================================================================
-Setting property : r
-On object: mycircle
-selected_property: r
-value: 3
-self.yc : 2
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
----------------------------
-obj.name == myline1
-obj.name == myline2
-name_str: mycircle
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-Circle equation bullshit: 
-((x)-(10))**2+((y)-(2))**2=(3)**2
-oof
-oof22
-All equations as a list: [Eq(x, 7.0), Eq(y, 2.0), Eq((x - 10)**2 + (y - 2)**2, 9)]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[[x - 7, (x - 10)**2 + (y - 2)**2 - 9, y - 2]]
-[7, x]
-[2, y]
-[9, (x - 10)**2 + (y - 2)**2]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-result: [(7.00000000000000, 2.00000000000000)]
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [(7.00000000000000, 2.00000000000000)][0m
-Results thing: [(7.00000000000000, 2.00000000000000)]
-Command result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Expected final result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-command_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-expected_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-[92mTestsuite tests/check_point_on_circle.txt passed![0m
-Running test check_min_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-Command result: 3*sqrt(5)/5
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 3*sqrt(5)/5
-Expected final result: 3*sqrt(5)/5
-command_result: 3*sqrt(5)/5
-expected_result: 3*sqrt(5)/5
-[92mTestsuite tests/check_min_output_dot_line.txt passed![0m
-Running test check_lines_angle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_lines_angle.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linefirst
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linefirst
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linesecond
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linesecond
-result: None
-Command string: 
-Command string: angle_lines linefirst linesecond
-fewfeewfewfewf
-name_str: linefirst
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-name_str: linesecond
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-obj.name == linefirst
-[94mAngle between lines: -57.2957795130823*atan(1/2) + 57.2957795130823*atan(4/5) == 12.0947570770121[0m
-Command result: 12.0947570770121
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 12.0947570770121
-Expected final result: 66
-command_result: 12.0947570770121
-expected_result: 66
-[91mTestsuite tests/check_lines_angle.txt failed![0m
-Running test check_line_triangle_intersection.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_triangle_intersection.txt.
-Command string: 
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle1
-setting parameter x0 to this: x01
-the_object.name == triangle1
-setting parameter y0 to this: y01
-the_object.name == triangle1
-setting parameter x1 to this: x11
-the_object.name == triangle1
-setting parameter y1 to this: y11
-the_object.name == triangle1
-setting parameter x2 to this: x21
-the_object.name == triangle1
-setting parameter y2 to this: y21
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-Command result: 0
-Command string: line a=0.1 b=1 c=-0.5
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-arguments: ['a=0.1', 'b=1', 'c=-0.5']
-object_name: line
-{'a': '0.1', 'b': '1', 'c': '-0.5'}
-*arguments_thing : {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 line0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'line0']
-obj_name1 : triangle0
-obj_name2 : line0
-name_str: triangle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-line0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-name_str: line0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-line0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-obj.name == linefirst
-obj.name == linesecond
-obj.name == triangle1
-poopooo
-obj1: <__main__.triangle object at 0x7f142df0cc10>
-obj2: =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f142df0cc10>
-object2 : =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.line'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq(0.1*x + y - 0.5, 0)]
-Final plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[[5*x - 30*y + 1, x/10 + y - 1/2]]
-[-1, 5*x - 30*y]
-[1/2, x/10 + y]
-Matrix([[5, -30, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: {x: 1.75000000000000, y: 0.325000000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {x: 1.75000000000000, y: 0.325000000000000}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[[-3*x + 2*y + 1, x/10 + y - 1/2]]
-[-1, -3*x + 2*y]
-[1/2, x/10 + y]
-Matrix([[-3, 2, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: {x: 0.625000000000000, y: 0.437500000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {x: 0.625000000000000, y: 0.437500000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[[1 - x, x/10 + y - 1/2]]
-[1, x]
-[1/2, x/10 + y]
-Matrix([[1, 0, 1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: {x: 1.00000000000000, y: 0.400000000000000}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {x: 1.00000000000000, y: 0.400000000000000}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}][0m
-Command result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Expected final result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-command_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-expected_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-[92mTestsuite tests/check_line_triangle_intersection.txt passed![0m
-Running test check_area_between_intersections.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_area_between_intersections.txt.
-Command string: 
-Command string: line a=4 b=-2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-arguments: ['a=4', 'b=-2', 'c=3']
-object_name: line
-{'a': '4', 'b': '-2', 'c': '3'}
-*arguments_thing : {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-the_object.name == line3
-setting parameter a to this: a3
-the_object.name == line3
-setting parameter b to this: b3
-the_object.name == line3
-setting parameter c to this: c3
-the_object.name == line3
-setting parameter x to this: x3
-the_object.name == line3
-setting parameter y to this: y3
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: area_between_intersections myline y=x**2-10*x+10
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-oof
-oof22
-[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]]
-[-3, x + 2*y]
-[10, -x**2 + 10*x + y]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-intersection_points == [(19/4 - sqrt(177)/4, -31/8 + sqrt(177)/8), (sqrt(177)/4 + 19/4, -31/8 - sqrt(177)/8)]
-thingoof intersection_x_values ==
-[x + 2*y + 0 + 3]
-[y]
-ok so it is a bare function and not a system of equations
-[-x**2 + 10*x + y - 10]
-[y]
-ok so it is a bare function and not a system of equations
-functions_in_y_format == [[-x/2 - 3/2], [x**2 - 10*x + 10]]
-bigger function: -x/2 - 3/2
-smaller_fun : x**2 - 10*x + 10
-intersection_x_values[0] == 19/4 - sqrt(177)/4
-intersection_x_values[1] == sqrt(177)/4 + 19/4
-[33mArea: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4[0m
-Command result: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-Expected final result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-command_result: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-expected_result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-[91mTestsuite tests/check_area_between_intersections.txt failed![0m
-Running test check_min_dist_point_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_dist_point_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistpointobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-oof
-oof22
-radiuses : 3*sqrt(5)/5
-Returning this: (x-0.0)**2+(y-0.0)**2=(3*sqrt(5)/5)**2
-circle_equation : [Eq(x**2 + y**2, 9/5)]
-all equations: [Eq(x + 2*y + 3, 0), Eq(x**2 + y**2, 9/5)]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]]
-[-3, x + 2*y]
-[9/5, x**2 + y**2]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-Result: [(-3/5, -6/5)]
-Resulting dict: {'x': -3/5, 'y': -6/5}
-oofstring1: -3/5
-oofstring2: -6/5
-oofstring1 after: -3/5
-oofstring2 after: -6/5
-final_dict: {'x': '-3/5', 'y': '-6/5'}
-Command result: {'x': '-3/5', 'y': '-6/5'}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': '-3/5', 'y': '-6/5'}
-Expected final result: {'x': '-3/5', 'y': '-6/5'}
-command_result: {'x': '-3/5', 'y': '-6/5'}
-expected_result: {'x': '-3/5', 'y': '-6/5'}
-[92mTestsuite tests/check_min_dist_point_line.txt passed![0m
-results list: [True, True, True, True, True, True, True, True, False, True, False, True]
-[94m=================================================
-
-[0m
-[94mFinal results: 
-[0m
-[92mTest: tests/check_var_assignment_to_function_result.txt PASSED![0m
-[92mTest: tests/check_line_intersect.txt PASSED![0m
-[92mTest: tests/check_var_subsequences.txt PASSED![0m
-[92mTest: tests/check_max_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_intersection_triangle_circle.txt PASSED![0m
-[92mTest: tests/check_integral.txt PASSED![0m
-[92mTest: tests/check_point_on_circle.txt PASSED![0m
-[92mTest: tests/check_min_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_lines_angle.txt PASSED![0m
-[92mTest: tests/check_line_triangle_intersection.txt PASSED![0m
-[92mTest: tests/check_area_between_intersections.txt PASSED![0m
-[92mTest: tests/check_min_dist_point_line.txt PASSED![0m
-
-
-
-[92mAll tests passed!
-
-[0m
-[94m=================================================[0m
diff --git a/test_derivative.py b/test_derivative.py
deleted file mode 100644
index 15b1010..0000000
--- a/test_derivative.py
+++ /dev/null
@@ -1,19 +0,0 @@
-
-from geometrylib import *
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-
-
-	x = Symbol('x')
-	function = x**2
-	result = get_tangent_from_point_and_derivative(x,function)
-
-	print(result.subs({"xnew":"3"}))
diff --git a/testing.py b/testing.py
deleted file mode 100644
index 40d108f..0000000
--- a/testing.py
+++ /dev/null
@@ -1,26 +0,0 @@
-
-
-
-def get_range(x0,y0,x1,y1):
-
-	# get the range of numbers:
-	
-	output = []
-
-	if x0 > x1:
-		output.append("x>="+str(x1))
-		output.append("x<="+str(x0))
-	else:
-		output.append("x<="+str(x1))
-		output.append("x>="+str(x0))
-
-	if y0 > y1:
-		output.append("y>="+str(y1))
-		output.append("y<="+str(y0))
-	else:
-		output.append("y<="+str(y1))
-		output.append("y>="+str(y0))
-
-	return output
-
-
diff --git a/thing b/thing
deleted file mode 100644
index 9d31705..0000000
--- a/thing
+++ /dev/null
@@ -1,1278 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/thing.txt b/thing.txt
deleted file mode 100644
index 3f52213..0000000
--- a/thing.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-area_between_intersections x**2=4*y y**2=4*x
-quit
diff --git a/thingbackups/fewjfnewknjkgnrjknrejkgern.py b/thingbackups/fewjfnewknjkgnrjknrejkgern.py
deleted file mode 100644
index e74aaea..0000000
--- a/thingbackups/fewjfnewknjkgnrjknrejkgern.py
+++ /dev/null
@@ -1,1599 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = {}
-# commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return results
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		if not any("[" in a for a in stuff): # check unpack thing
-
-			fail("Invalid number of arguments: "+str(command_string))
-			fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-			return 1
-		else:
-			return 0
-	return 0
-
-
-def check_common_syntax_var(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[3:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-# variable_assignment_command(command_string, global_objects)
-
-def variable_assignment_command(command_string: str, global_objects: list, max_arg_lengths: list, min_arg_lengths: list, commands: list) -> int:
-
-	tokens = command_string.split(" ")
-
-	if tokens[1] != ":=":
-		fail("Invalid variable assignment command: "+str(command_string))
-		return 1
-
-
-
-	# the new variable name is tokens[0]
-	new_var_name = tokens[0]
-
-	assigning_command = tokens[2:] # the command is after the "variable :="   part .
-
-	new_command_string = ' '.join(assigning_command)
-
-
-
-	result = check_common_syntax_var(new_command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-	if result:
-		return 1
-
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	index = commands.index(new_command_string.split(" ")[0])
-
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-
-	var_values = handle_functions[index](new_command_string, global_objects)
-
-	print("var_values : "+str(var_values))
-
-
-
-	user_defined_variables[new_var_name] = var_values
-	print("var_values.keys()" + str(var_values.keys()))
-	print(str([str(a) for a in var_values.keys()]))
-	print(str([str(a) for a in var_values.values()]))
-	return 0
-
-
-
-
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-# command_string = unpack_variables_in_command(command_string, user_defined_variables)
-
-def unpack_variables_in_command(command_string:str, user_defined_variables: list):
-
-	tokens = command_string.split(" ")
-	
-	generated_command = []
-	for token in tokens:
-		if "[" not in token or "]" not in token: # if there is nothing to unpack then just append as is
-			generated_command.append(token)
-		else:
-
-			start = None
-			end = None
-			if token.count("[") > 1 or token.count("]") > 1:
-
-				# get only partial part of the result:
-
-				partial = token[token.index("]")+1:] # get the rest of the thing
-				start = partial[1:partial.index(":")]
-				end = partial[partial.index(":")+1:partial.index("]")]
-				start = int(start)
-				end= int(end)
-
-
-				#fail("Subtokens like [myvar][a:b] are not implemented.")
-				#return 1
-
-			var_name = token[token.index("[")+1:token.index("]")] # get the variable name from inside the brackets
-			if var_name not in user_defined_variables.keys():
-				fail("Undefined variable: "+str(var_name)+" .")
-				return 1
-
-
-			var_values = user_defined_variables[var_name]
-
-			print("str(var_values) == "+str(str(var_values)))
-			print("start == "+str(start))
-			print("end == "+str(end))
-			if start != None and end != None:
-				
-				print("abcdefg")
-				# print({k:d[k] for k in l if k in d})
-				'''
-				d = {1:2, 3:4, 5:6, 7:8}
-
-				# the subset of keys I'm interested in
-				l = (1,5)
-
-				'''
-				l = tuple([list(var_values.keys())[x] for x in range(start, end)])
-				print("l == "+str(l))
-
-				var_values = {k:var_values[k] for k in l if k in var_values}
-
-
-			print("var_values final: "+str(var_values))
-
-			replacement = ' '.join([str(key)+str("=")+str(var_values[key]) for key in var_values.keys()])
-
-			generated_command.append(replacement)
-	final_command = ' '.join(generated_command)
-	return final_command
-
-
-# mindistobjdot(command:str, objects:list):
-
-def integrate_command(command: str, objects: list):
-
-	# integrate a function over xstart to xend
-
-	tokens = command.split(" ")
-	selected_object = tokens[1]
-
-	int_var = tokens[2] # variable is assumed to be next
-	xstart = tokens[3]
-	xend = tokens[4]
-	expression = None
-
-	if selected_object not in get_names(global_objects):
-		# the input is assumed to be a literal expression
-		equation = Eq(parse_expr(selected_object[:selected_object.index("=")]), parse_expr(selected_object[selected_object.index("=")+1:]))
-		expressions = [equation]
-
-	else:
-		expressions = get_object_by_name(selected_object).get_equations()
-
-	# if there are multiple equations for the object, then make the user choose which of them:
-
-	if len(expressions) > 1:
-		warn("The object you selected has multiple equations associated with it: ")
-		count = 0
-		for expr in expressions:
-			print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-			count += 1
-		print("Please select the index of the desired expr: ")
-		index = int(input("> "))
-		selected_expr = expressions[index]
-	else:
-		selected_expr = expressions[0]
-
-	x = Symbol('x')
-	y = Symbol('y')
-
-	print("selected_expr: "+str(selected_expr))
-	y_function = solve(selected_expr,y)
-	print("y_function: " +str(y_function))
-	y_function = y_function[0]
-	result = integrate(y_function,(x,xstart, xend))
-
-	print(CYELLOW + "Result: "+str(result) + bcolors.ENDC)
-
-	return result
-
-
-
-def area_between_intersections(command:str, objects:list):
-
-	# calculate the area between the two intersection points of two graphs
-
-	# the syntax for this problem would be "commandstring" object1 object2
-
-	# parse command
-
-
-	tokens = command.split(" ")
-
-
-	equation_list = []
-
-
-
-	# get equations from the arguments:  (I should probably makes this a function in itself to check if an arguments a raw expression or an object itself. )
-
-	for i in range(1,3):
-		object_name = tokens[i]
-
-		if object_name not in get_names(objects):
-			# assumed to be a raw expression
-			equation = Eq(parse_expr(object_name[:object_name.index("=")]), parse_expr(object_name[object_name.index("=")+1:]))
-			expressions = [equation]
-
-		else:
-			# object
-			expressions = get_object_by_name(selected_object).get_equations()
-
-		if len(expressions) > 1:
-			warn("The object you selected has multiple equations associated with it: ")
-			count = 0
-			for expr in expressions:
-				print(CBLUE +str("[{}] ".format(count)) + str(expr)+bcolors.ENDC)
-				count += 1
-			print("Please select the index of the desired expr: ")
-			index = int(input("> "))
-			selected_expr = expressions[index]
-		else:
-			selected_expr = expressions[0]
-		equation_list.append(selected_expr)
-			
-	# get intersection points:
-
-	# def intersection(object1, object2):
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-	'''
-
-
-
-
-
-
-
-	intersection_points = Solve(equation_list, ('x', 'y'))
-
-	if len(intersection_points)[0] < 2:
-		fail("Not enough intersection points for the integral command!")
-		return 1
-
-	intersection_x_values = intersection_points[0]
-
-
-	# make the difference function
-
-	#functions_in_y_format = Solve(equation_list, ('y'))
-
-	#function1 = functions_in_y_format[0]
-	functions_in_y_format = []
-
-	for eq in equation_list:
-		functions_in_y_format.append(Solve(eq, ('y')))
-
-	intersection_x_values = sorted(intersection_x_values)
-
-	check_value = random.uniform(intersection_x_values[0], intersection_x_values[1])
-
-
-
-	# see which function is larger in that range
-
-	if functions_in_y_format[0].subs({'x':check_value}) > functions_in_y_format[1].subs({'x':check_value}):
-
-		bigger_function = functions_in_y_format[0]
-		smaller_fun = functions_in_y_format[1]
-	else:
-		bigger_function = functions_in_y_format[1]
-		smaller_fun = functions_in_y_format[0]
-
-
-	difference_function = parse_expr(bigger_function - smaller_fun)
-
-	resulting_area = integrate(difference_function, (x, intersection_x_values[0], intersection_x_values[1]))
-
-	print(CYELLOW + "Area: "+str(resulting_area) + ENDC)
-
-	
-
-	return resulting_area
-
-
-	#obj1 = get_object_by_name(tokens[1])
-	#obj2 = get_object_by_name(tokens[2])
-
-
-
-
-
-
-
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot", "integrate"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2,4]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2,4]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot, integrate_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-
-			if ":=" in command_string: # check variable assignment command
-				print("poopooshit")
-				result = variable_assignment_command(command_string, global_objects, max_arg_lengths, min_arg_lengths, commands)
-				if result:
-					fail("Invalid command: "+str(command_string))
-				continue
-
-
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-		
-		command_string = unpack_variables_in_command(command_string, user_defined_variables)  # this is to unpack arguments like [myvar]
-
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/thingbackups/geometrylib.py b/thingbackups/geometrylib.py
deleted file mode 100644
index 9d31705..0000000
--- a/thingbackups/geometrylib.py
+++ /dev/null
@@ -1,1278 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-#from sympy import Symbol
-#from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-from sympy.calculus.util import *
-
-
-
-global_things = []
-global_objects = []
-
-user_defined_variables = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print("string_oof_1 : "+str(string_oof_1))
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-		print("string_oof_2 == "+str(string_oof_2))
-		self.b = sympy.simplify(string_oof_2)
-
-		print("self.a =="+str(self.a))
-		print("self.b =="+str(self.b))
-
-
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		equation = "("+str(self.a)+")*"+"x"+"+("+str(self.b)+")*"+"y"+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-def distance_thing(x0,y0,x1,y1):
-	print("bullshit ooof :::: "+str("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1)))
-	return sympy.simplify("sqrt(({}-{})**2+({}-{})**2)".format(x0,x1,y0,y1))
-
-
-
-def distance_min(object, point, maximumthing=False):
-
-	x1 = point.x
-	y1 = point.y
-
-	x0 = 'x'
-	object_equation = object.get_equations()[0]  # support only a thing which has a single equation per object for now :)
-	print("object_equation : "+str(object_equation))
-	y0 = sympy.solve(object_equation, 'y')  # make it of the form: y=...
-	y0 = y0[0]
-	print("y0 : "+str(y0))
-	x = sympy.Symbol('x')
-
-	distance_function = distance_thing(x0,y0,x1,y1) # at this point in a case where there are all known values for the objects this should return a function which only has one variable: "x"
-
-	print("distance_function : "+str(distance_function))
-
-	# thanks to https://computationalmindset.com/en/mathematics/experiments-with-sympy-to-solve-odes-1st-order.html
-	f = symbols('f', cls=Function) # make the distance function
-	f = distance_function
-
-
-
-	if not maximumthing:
-
-		solution = minimum(distance_function, x)
-	else:
-		solution = maximum(distance_function, x)
-
-	print("solution: "+str(solution))
-	print("distance_function : "+str(distance_function))
-
-	
-
-	return solution
-
-
-def mindistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=False)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Minimum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def maxdistobjdot(command:str, objects:list):
-
-	# the first object can be anything, but the second argument must be a point
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-	
-	object_thing = get_object_by_name(arguments[0])
-
-	dot_thing = get_object_by_name(arguments[1])
-
-	solution = distance_min(object_thing, dot_thing, maximumthing=True)
-
-	if solution == []:
-		print("No results for some reason")
-		return 0
-	else:
-		print("Maximum distance: " + str(solution))
-		return solution
-
-
-	return 0
-
-def get_circle_eq(xc,yc,r):
-	print("Returning this: "+str("(x-{})**2+(y-{})**2=({})**2".format(xc,yc,r)))
-	return [Eq(parse_expr("(x-{})**2+(y-{})**2".format(xc,yc)), parse_expr("({})**2".format(r)))]  # remember to write about the {}**2 instead of ({})**2 bug
-
-
-def mindistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = mindistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-def maxdistpointobjdot(command:str, objects:list):
-	
-	arguments = command.split(" ")
-	arguments = arguments[1:]
-
-	radiuses = maxdistobjdot(command, objects)
-	point = get_object_by_name(arguments[1])
-	other_object = get_object_by_name(arguments[0])
-	equations = other_object.get_equations()
-	print("radiuses : "+str(radiuses))
-	radius = radiuses
-	x = sympy.Symbol('x')
-	y = sympy.Symbol('y')
-
-	'''
-	all_equations = equations1 + equations2
-	print("All equations as a list: "+str(all_equations))
-
-
-	result = sympy.solve(all_equations, ('x', 'y'))
-	print("result: "+str(result))
-	'''
-
-
-	
-	circle_equation = get_circle_eq(point.x, point.y, radius)
-	print("circle_equation : "+str(circle_equation))
-	equations += circle_equation
-	print("all equations: "+str(equations))
-	result = sympy.solve(equations, ('x', 'y'))
-
-	print("Result: "+str(result))
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point", "mindistobjdot", "maxdistobjdot", "mindistpointobjdot", "maxdistpointobjdot"]
-	min_arg_lengths = [0,0,0,0,0,0,0,2,2,2,2]
-	max_arg_lengths = [3,2,0,0,0,3,2,2,2,2,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command, mindistobjdot, maxdistobjdot, mindistpointobjdot, maxdistpointobjdot]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/things/oof.py b/things/oof.py
deleted file mode 100644
index 6661415..0000000
--- a/things/oof.py
+++ /dev/null
@@ -1,79 +0,0 @@
-import tkinter as tk
-import sympy as sp
-from tkinter import Text
-
-
-def clean_input(x: str) -> list:
-    temp = x.replace(' ', '').split('\n')
-    cleaned = list(filter(None, temp))
-    return cleaned
-
-
-def create_res(x: str):
-    split = x.split('=')
-    res_eq = (sp.parse_expr(split[0], evaluate=False) - sp.parse_expr(split[1], evaluate=False))
-    return res_eq
-
-
-def define_eqsys_vars(eqsys: list):
-    unique_vars = set()
-    for eq in eqsys:
-        unique_vars = unique_vars.union(eq.atoms(sp.Symbol))
-
-    # create a list with all symbols converted to text, and join - var() takes a string
-    var_string = ', '.join([repr(eq) for eq in unique_vars])
-    variables = sp.var(var_string)
-    return variables
-
-
-def create_eqsys(x: list) -> tuple:
-    equation_system = [create_res(eq) for eq in x]
-    variables = define_eqsys_vars(equation_system)
-    return equation_system, variables
-
-
-def create_guess(eqsys: list) -> tuple:
-    unique_vars = set()
-    for eq in eqsys:
-        unique_vars = unique_vars.union(eq.atoms(sp.Symbol))
-    guess = [1] * len(unique_vars)
-    return tuple(guess)
-
-
-def solve_eqsys(eqsys, symbols, guess):
-    result = sp.nsolve(tuple(eqsys), symbols, guess)
-    return result
-
-
-def main():
-    # input, from tkinter window
-    text_input = inputtxt.get("1.0", "end-1c")
-
-    # clean text
-    cleaned_text = clean_input(text_input)
-
-    # create system of equations and try to solve it
-    eqsys, eqsys_vars = create_eqsys(cleaned_text)
-    guess = create_guess(eqsys)
-    solution = solve_eqsys(eqsys, eqsys_vars, guess)
-
-    # text output
-    Output.insert(tk.END, f"Solution: {solution}")
-
-    return 
-
-
-# Build GUI
-root = tk.Tk()
-toplabel = tk.Label(text="Start variable name with a letter")
-inputtxt = Text(root, height=30, width=50, bg="light yellow")
-Output = Text(root, height=30, width=25, bg="light cyan")
-Display = tk.Button(root, height=2,
-                    width=20,
-                    text="Solve system of equations",
-                    command=lambda: main())
-toplabel.pack()
-inputtxt.pack()
-Display.pack()
-Output.pack()
-tk.mainloop()
\ No newline at end of file
diff --git a/triangleproblempart1.txt b/triangleproblempart1.txt
deleted file mode 100644
index 30d9e01..0000000
--- a/triangleproblempart1.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-circle xc=0 yc=0 r=762
-circle0.name = origincircle
-circle xc=356 yc=0 r=558
-circle0.name = anothercircle
-intersect anothercircle origincircle
-quit
diff --git a/triangleproblempart2.txt b/triangleproblempart2.txt
deleted file mode 100644
index 5dab7fc..0000000
--- a/triangleproblempart2.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-line a=-1.455 b=-1 c=517.0
-line0.name = halwayline
-line
-line0.name = side
-point x=278.1011235955055 y=260.42
-point0.name = shitpoint
-point x=556.202247191011 y=520.8484042595016
-side.set_values_two_points shitpoint point0
-intersect side halwayline
-quit
diff --git a/ttt.txt b/ttt.txt
deleted file mode 100644
index 29d9c34..0000000
--- a/ttt.txt
+++ /dev/null
@@ -1,2365 +0,0 @@
-Running test check_var_assignment_to_function_result.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_assignment_to_function_result.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1']
-global_objects at the start: ['myline1']
-objects after creation of new_object : ['myline1']
-gregregregrr
-global_objects at the start: ['myline1', 'line0']
-objects after appending new_object: ['myline1', 'line0']
-global_objects after appending new_object: ['myline1', 'line0']
-objects at the end: ['myline1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2']
----------------------------
-myline1
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == None
-end == None
-var_values final: {x: 1, y: -2}
-arguments: ['x=1', 'y=-2']
-object_name: point
-{'x': '1', 'y': '-2'}
-*arguments_thing : {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-bullshit: {'x': '1', 'y': '-2'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2']
-global_objects at the start: ['myline1', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = -2
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = -2name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[92mTestsuite tests/check_var_assignment_to_function_result.txt passed![0m
-Running test check_line_intersect.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_intersect.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line1
-setting parameter a to this: a1
-the_object.name == line1
-setting parameter b to this: b1
-the_object.name == line1
-setting parameter c to this: c1
-the_object.name == line1
-setting parameter x to this: x1
-the_object.name == line1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'line0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'line0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect line0 line1
-fewfeewfewfewf
-Args : ['intersect', 'line0', 'line1']
-obj_name1 : line0
-obj_name2 : line1
-name_str: line0
-['myline1', 'myline2', 'mypoint', 'line0', 'line1']
----------------------------
-myline1
-myline2
-mypoint
-line0
-line1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-name_str: line1
-['myline1', 'myline2', 'mypoint', 'line0', 'line1']
----------------------------
-myline1
-myline2
-mypoint
-line0
-line1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == line0
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = line0
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = line1
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Command result: {x: 1, y: -2}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {x: 1, y: -2}
-Expected final result: {x: 1, y: -2}
-command_result: {x: 1, y: -2}
-expected_result: {x: 1, y: -2}
-[92mTestsuite tests/check_line_intersect.txt passed![0m
-Running test check_var_subsequences.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_var_subsequences.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line2
-setting parameter a to this: a2
-the_object.name == line2
-setting parameter b to this: b2
-the_object.name == line2
-setting parameter c to this: c2
-the_object.name == line2
-setting parameter x to this: x2
-the_object.name == line2
-setting parameter y to this: y2
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'line0', 'line1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'line0', 'line1', 'line2']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline1
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline1
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline2
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline2
-result: None
-Command string: myvar := intersect myline1 myline2
-poopooshit
-fewfeewfewfewf
-stuff == ['myline1', 'myline2']
-command_string: intersect myline1 myline2
-new_command_string == intersect myline1 myline2
-Running subcommand: intersect
-Args : ['intersect', 'myline1', 'myline2']
-obj_name1 : myline1
-obj_name2 : myline2
-name_str: myline1
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
----------------------------
-name_str: myline2
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
----------------------------
-obj.name == myline1
-poopooo
-obj1: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-obj2: =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-================================================
-object1 : =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline1
-=======================
-		
-object2 : =======================
-Type: line
-a = 4
-b = 5
-c = 6
-name = myline2
-=======================
-		
-object1 : <class '__main__.line'>
-object2 : <class '__main__.line'>
-================================================
-oof
-oof22
-oof
-oof22
-All equations as a list: [Eq(x + 2*y + 3, 0), Eq(4*x + 5*y + 6, 0)]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]
-[x, y]
-[[x + 2*y + 0 + 3, 4*x + 5*y + 0 + 6]]
-[-3, x + 2*y]
-[-6, 4*x + 5*y]
-Matrix([[1, 2, -3], [4, 5, -6]])
-result: {x: 1, y: -2}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: {x: 1, y: -2}[0m
-Returned from the assignment command:
-var_values : {x: 1, y: -2}
-var_values.keys()dict_keys([x, y])
-['x', 'y']
-['1', '-2']
-Command string: point [myvar][0:1]
-fewfeewfewfewf
-str(var_values) == {x: 1, y: -2}
-start == 0
-end == 1
-abcdefg
-l == (x,)
-var_values final: {x: 1}
-arguments: ['x=1']
-object_name: point
-{'x': '1'}
-*arguments_thing : {'x': '1'}
-bullshit: {'x': '1'}
-bullshit: {'x': '1'}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint
-thing
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-=======================
-Type: point
-x = 1
-y = -2
-name = mypoint
-=======================
-
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: =======================Type: pointx = 1y = -2name = mypoint=======================
-Expected final result: =======================Type: pointx = 1y = -2name = mypoint=======================
-command_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-expected_result: =======================Type: pointx = 1y = -2name = mypoint=======================
-[92mTestsuite tests/check_var_subsequences.txt passed![0m
-Running test check_max_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_max_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: maxdistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: oo
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Maximum distance: oo
-Command result: oo
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: oo
-Expected final result: oo
-command_result: oo
-expected_result: oo
-[92mTestsuite tests/check_max_output_dot_line.txt passed![0m
-Running test check_intersection_triangle_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_intersection_triangle_circle.txt.
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle0
-setting parameter x0 to this: x00
-the_object.name == triangle0
-setting parameter y0 to this: y00
-the_object.name == triangle0
-setting parameter x1 to this: x10
-the_object.name == triangle0
-setting parameter y1 to this: y10
-the_object.name == triangle0
-setting parameter x2 to this: x20
-the_object.name == triangle0
-setting parameter y2 to this: y20
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-Command result: 0
-Command string: circle xc=0.8 yc=0.4 r=0.3
-fewfeewfewfewf
-arguments: ['xc=0.8', 'yc=0.4', 'r=0.3']
-object_name: circle
-{'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-*arguments_thing : {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-bullshit: {'xc': '0.8', 'yc': '0.4', 'r': '0.3'}
-the_object.name == circle0
-setting parameter xc to this: xc0
-the_object.name == circle0
-setting parameter yc to this: yc0
-the_object.name == circle0
-setting parameter r to this: r0
-the_object.name == circle0
-setting parameter x to this: x0
-the_object.name == circle0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 circle0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'circle0']
-obj_name1 : triangle0
-obj_name2 : circle0
-name_str: triangle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-circle0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-name_str: circle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-circle0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-poopooo
-obj1: <__main__.triangle object at 0x7f065a62cbe0>
-obj2: =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f065a62cbe0>
-object2 : =======================
-Type: circle
-x0 = 0.8
-y0 = 0.4
-r = 0.3
-name = circle0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.circle'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-Circle equation bullshit: 
-((x)-(0.8))**2+((y)-(0.4))**2=(0.3)**2
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-Final plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[5*x - 30*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, 5*x - 30*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(5*x - 30*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: [(0.648031893339682, 0.141338648889947), (1.02764378233599, 0.204607297055999)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 0.648031893339682, 'y': 0.141338648889947}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {'x': 1.02764378233599, 'y': 0.204607297055999}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[-3*x + 2*y + 1, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[-1, -3*x + 2*y]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(-3*x + 2*y + 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: [(0.523076923076923, 0.284615384615385), (0.800000000000000, 0.700000000000000)]
-poopoo
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.523076923076923, 'y': 0.284615384615385}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {'x': 0.800000000000000, 'y': 0.700000000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq((x - 0.8)**2 + (y - 0.4)**2, 0.09)]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]
-[x, y]
-[[1 - x, (x - 4/5)**2 + (y - 2/5)**2 - 9/100]]
-[1, x]
-[9/100, (x - 4/5)**2 + (y - 2/5)**2]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-[Poly(x - 1, x, y, domain='ZZ'), Poly(2500*x**2 - 4000*x + 2500*y**2 - 2000*y + 1775, x, y, domain='ZZ')]
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: [(1.00000000000000, 0.176393202250021), (1.00000000000000, 0.623606797749979)]
-poopoo
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.176393202250021}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {'x': 1.00000000000000, 'y': 0.623606797749979}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}][0m
-Command result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-Expected final result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-command_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-expected_result: [{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-[92mTestsuite tests/check_intersection_triangle_circle.txt passed![0m
-Running test check_integral.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_integral.txt.
-Command string: integrate y=x**2 x 1 3
-fewfeewfewfewf
-selected_expr: Eq(y, x**2)
-[-x**2 + y]
-[y]
-ok so it is a bare function and not a system of equations
-y_function: [x**2]
-[33mResult: 26/3[0m
-Command result: 26/3
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 26/3
-Expected final result: 26/3
-command_result: 26/3
-expected_result: 26/3
-[92mTestsuite tests/check_integral.txt passed![0m
-Running test check_point_on_circle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_point_on_circle.txt.
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 7 2
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 7 2
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 7.0
-self.y == 2.0
-x_in: 7.0
-y_in: 2.0
-result: 0
-Command string: circle
-fewfeewfewfewf
-arguments: []
-object_name: circle
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == circle1
-setting parameter xc to this: xc1
-the_object.name == circle1
-setting parameter yc to this: yc1
-the_object.name == circle1
-setting parameter r to this: r1
-the_object.name == circle1
-setting parameter x to this: x1
-the_object.name == circle1
-setting parameter y to this: y1
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'circle0', 'mypoint', 'circle1']
-[92mCreated new object.[0m
-Command result: 0
-Command string: circle0.name = mycircle
-thing
-==================================================================================
-Setting property : name
-On object: circle0
-selected_property: name
-value: mycircle
-self.yc : 0.4
-result: None
-Command string: mycircle.xc = 10
-thing
-==================================================================================
-Setting property : xc
-On object: mycircle
-selected_property: xc
-value: 10
-self.yc : 0.4
-result: None
-Command string: mycircle.yc = 2
-thing
-==================================================================================
-Setting property : yc
-On object: mycircle
-selected_property: yc
-value: 2
-self.yc : 0.4
-result: None
-Command string: mycircle.r = 3
-thing
-==================================================================================
-Setting property : r
-On object: mycircle
-selected_property: r
-value: 3
-self.yc : 2
-result: None
-Command string: intersect mypoint mycircle
-fewfeewfewfewf
-Args : ['intersect', 'mypoint', 'mycircle']
-obj_name1 : mypoint
-obj_name2 : mycircle
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
----------------------------
-obj.name == myline1
-obj.name == myline2
-name_str: mycircle
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-poopooo
-obj1: =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-obj2: =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-================================================
-object1 : =======================
-Type: point
-x = 7.0
-y = 2.0
-name = mypoint
-=======================
-
-object2 : =======================
-Type: circle
-x0 = 10
-y0 = 2
-r = 3
-name = mycircle
-=======================
-		
-object1 : <class '__main__.point'>
-object2 : <class '__main__.circle'>
-================================================
-left_side_1 : x
-right_side_1 : 7.0
-first_equation : Eq(x, 7.0)
-second_equation : Eq(y, 2.0)
-Circle equation bullshit: 
-((x)-(10))**2+((y)-(2))**2=(3)**2
-oof
-oof22
-All equations as a list: [Eq(x, 7.0), Eq(y, 2.0), Eq((x - 10)**2 + (y - 2)**2, 9)]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[x - 7, y - 2, (x - 10)**2 + (y - 2)**2 - 9]
-[x, y]
-[[x - 7, (x - 10)**2 + (y - 2)**2 - 9, y - 2]]
-[7, x]
-[2, y]
-[9, (x - 10)**2 + (y - 2)**2]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-[Poly(x - 7, x, y, domain='ZZ'), Poly(y - 2, x, y, domain='ZZ'), Poly(x**2 - 20*x + y**2 - 4*y + 95, x, y, domain='ZZ')]
-result: [(7.00000000000000, 2.00000000000000)]
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [(7.00000000000000, 2.00000000000000)][0m
-Results thing: [(7.00000000000000, 2.00000000000000)]
-Command result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': 7.00000000000000, 'y': 2.00000000000000}
-Expected final result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-command_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-expected_result: {'x': 7.00000000000000, 'y': 2.00000000000000}
-[92mTestsuite tests/check_point_on_circle.txt passed![0m
-Running test check_min_output_dot_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_output_dot_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-Command result: 3*sqrt(5)/5
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 3*sqrt(5)/5
-Expected final result: 3*sqrt(5)/5
-command_result: 3*sqrt(5)/5
-expected_result: 3*sqrt(5)/5
-[92mTestsuite tests/check_min_output_dot_line.txt passed![0m
-Running test check_lines_angle.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_lines_angle.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linefirst
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linefirst
-result: None
-Command string: line a=4 b=5 c=6
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-arguments: ['a=4', 'b=5', 'c=6']
-object_name: line
-{'a': '4', 'b': '5', 'c': '6'}
-*arguments_thing : {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-bullshit: {'a': '4', 'b': '5', 'c': '6'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = linesecond
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: linesecond
-result: None
-Command string: 
-Command string: angle_lines linefirst linesecond
-fewfeewfewfewf
-name_str: linefirst
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-name_str: linesecond
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-obj.name == linefirst
-[94mAngle between lines: -57.2957795130823*atan(1/2) + 57.2957795130823*atan(4/5) == 12.0947570770121[0m
-Command result: 12.0947570770121
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: 12.0947570770121
-Expected final result: 12.0947570770121
-command_result: 12.0947570770121
-expected_result: 12.0947570770121
-[92mTestsuite tests/check_lines_angle.txt passed![0m
-Running test check_line_triangle_intersection.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_line_triangle_intersection.txt.
-Command string: 
-Command string: triangle x0=0.4 y0=0.1 x1=1 y1=0.2 x2=1 y2=1
-fewfeewfewfewf
-arguments: ['x0=0.4', 'y0=0.1', 'x1=1', 'y1=0.2', 'x2=1', 'y2=1']
-object_name: triangle
-{'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-*arguments_thing : {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-bullshit: {'x0': '0.4', 'y0': '0.1', 'x1': '1', 'y1': '0.2', 'x2': '1', 'y2': '1'}
-the_object.name == triangle1
-setting parameter x0 to this: x01
-the_object.name == triangle1
-setting parameter y0 to this: y01
-the_object.name == triangle1
-setting parameter x1 to this: x11
-the_object.name == triangle1
-setting parameter y1 to this: y11
-the_object.name == triangle1
-setting parameter x2 to this: x21
-the_object.name == triangle1
-setting parameter y2 to this: y21
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-Command result: 0
-Command string: line a=0.1 b=1 c=-0.5
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-arguments: ['a=0.1', 'b=1', 'c=-0.5']
-object_name: line
-{'a': '0.1', 'b': '1', 'c': '-0.5'}
-*arguments_thing : {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-bullshit: {'a': '0.1', 'b': '1', 'c': '-0.5'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: intersect triangle0 line0
-fewfeewfewfewf
-Args : ['intersect', 'triangle0', 'line0']
-obj_name1 : triangle0
-obj_name2 : line0
-name_str: triangle0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-line0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-name_str: line0
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-line0
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline
-obj.name == mypoint
-obj.name == triangle0
-obj.name == mycircle
-obj.name == mypoint
-obj.name == circle1
-obj.name == myline
-obj.name == mypoint
-obj.name == linefirst
-obj.name == linesecond
-obj.name == triangle1
-poopooo
-obj1: <__main__.triangle object at 0x7f065a62cbe0>
-obj2: =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-================================================
-object1 : <__main__.triangle object at 0x7f065a62cbe0>
-object2 : =======================
-Type: line
-a = 0.1
-b = 1
-c = -0.5
-name = line0
-=======================
-		
-object1 : <class '__main__.triangle'>
-object2 : <class '__main__.line'>
-================================================
-Setting a to this: ((0.1)-(0.2))/((0.4*0.2)-(1*0.1))
-Line-equation thing: (5.00000000000000)*x+(-30.0000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.1)-(1))/((0.4*1)-(1*0.1))
-Line-equation thing: (-3.00000000000000)*x+(2.00000000000000)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-Setting a to this: ((0.2)-(1))/((1*1)-(1*0.2))
-Line-equation thing: (-1.00000000000000)*x+(0)*y+1=0
-self.x0 : 0.4
-self.x0 : 0.1
-self.x1 : 1
-self.y1 : 0.2
-self.x2 : 1
-self.y2 : 1
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 0.2
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 0.4
-y0: 0.1
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-=======================
-
-
-oofthingaaaa
-x0: 1
-y0: 0.2
-x1: 1
-y1: 1
-=======================
-
-
-Output: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Parsing equation: (5.00000000000000)*x+(-30.0000000000000)*y+1
-resulting thing: 5.0*x - 30.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=0.2', 'y>=0.1']
-Final equation: Eq(5.0*x - 30.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-3.00000000000000)*x+(2.00000000000000)*y+1
-resulting thing: -3.0*x + 2.0*y + 1
-constraint_thing: ['x<=1', 'x>=0.4', 'y<=1', 'y>=0.1']
-Final equation: Eq(-3.0*x + 2.0*y + 1, 0)
-Value of x: x
-Parsing equation: (-1.00000000000000)*x+(0)*y+1
-resulting thing: 1 - 1.0*x
-constraint_thing: ['x<=1', 'x>=1', 'y<=1', 'y>=0.2']
-Final equation: Eq(1 - 1.0*x, 0)
-Value of x: x
-oof
-oof22
-equations: [[Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]], [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]], [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]], Eq(0.1*x + y - 0.5, 0)]
-Final plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-or_eq1 : [Eq(5.0*x - 30.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[5*x - 30*y + 1, x/10 + y - 1/2]
-[x, y]
-[[5*x - 30*y + 1, x/10 + y - 1/2]]
-[-1, 5*x - 30*y]
-[1/2, x/10 + y]
-Matrix([[5, -30, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]]
-thing: {x: 1.75000000000000, y: 0.325000000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 0.2, y >= 0.1]
-substitution: {x: 1.75000000000000, y: 0.325000000000000}
-or_eq1 : [Eq(-3.0*x + 2.0*y + 1, 0), [x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[-3*x + 2*y + 1, x/10 + y - 1/2]
-[x, y]
-[[-3*x + 2*y + 1, x/10 + y - 1/2]]
-[-1, -3*x + 2*y]
-[1/2, x/10 + y]
-Matrix([[-3, 2, -1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 0.4, y <= 1, y >= 0.1]]
-thing: {x: 0.625000000000000, y: 0.437500000000000}
-current restriction: [x <= 1, x >= 0.4, y <= 1, y >= 0.1]
-substitution: {x: 0.625000000000000, y: 0.437500000000000}
-or_eq1 : [Eq(1 - 1.0*x, 0), [x <= 1, x >= 1, y <= 1, y >= 0.2]]
-plain_eqs: [Eq(0.1*x + y - 0.5, 0)]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[1 - x, x/10 + y - 1/2]
-[x, y]
-[[1 - x, x/10 + y - 1/2]]
-[1, x]
-[1/2, x/10 + y]
-Matrix([[1, 0, 1], [1, 10, 5]])
-Thing stuff: 
-restriction_thing: [[x <= 1, x >= 1, y <= 1, y >= 0.2]]
-thing: {x: 1.00000000000000, y: 0.400000000000000}
-current restriction: [x <= 1, x >= 1, y <= 1, y >= 0.2]
-substitution: {x: 1.00000000000000, y: 0.400000000000000}
-[33mObjects intersect atleast at one point.[0m
-[33mIntersections are at points: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}][0m
-Command result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-Expected final result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-command_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-expected_result: [{x: 0.625000000000000, y: 0.437500000000000}, {x: 1.00000000000000, y: 0.400000000000000}]
-[92mTestsuite tests/check_line_triangle_intersection.txt passed![0m
-Running test check_area_between_intersections.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_area_between_intersections.txt.
-Command string: 
-Command string: line a=4 b=-2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-arguments: ['a=4', 'b=-2', 'c=3']
-object_name: line
-{'a': '4', 'b': '-2', 'c': '3'}
-*arguments_thing : {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-the_object.name == line3
-setting parameter a to this: a3
-the_object.name == line3
-setting parameter b to this: b3
-the_object.name == line3
-setting parameter c to this: c3
-the_object.name == line3
-setting parameter x to this: x3
-the_object.name == line3
-setting parameter y to this: y3
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'line0', 'line3']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: area_between_intersections myline y=x**2-10*x+10
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-oof
-oof22
-[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[[x + 2*y + 0 + 3, -x**2 + 10*x + y - 10]]
-[-3, x + 2*y]
-[10, -x**2 + 10*x + y]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-intersection_points == [(19/4 - sqrt(177)/4, -31/8 + sqrt(177)/8), (sqrt(177)/4 + 19/4, -31/8 - sqrt(177)/8)]
-thingoof intersection_x_values ==
-[x + 2*y + 0 + 3]
-[y]
-ok so it is a bare function and not a system of equations
-[-x**2 + 10*x + y - 10]
-[y]
-ok so it is a bare function and not a system of equations
-functions_in_y_format == [[-x/2 - 3/2], [x**2 - 10*x + 10]]
-bigger function: -x/2 - 3/2
-smaller_fun : x**2 - 10*x + 10
-intersection_x_values[0] == 19/4 - sqrt(177)/4
-intersection_x_values[1] == sqrt(177)/4 + 19/4
-[33mArea: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4[0m
-Command result: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-Expected final result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-command_result: -(sqrt(177)/4 + 19/4)**3/3 - 23*sqrt(177)/4 - 19*(19/4 - sqrt(177)/4)**2/4 + (19/4 - sqrt(177)/4)**3/3 + 19*(sqrt(177)/4 + 19/4)**2/4
-expected_result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-[91mTestsuite tests/check_area_between_intersections.txt failed![0m
-Running test check_min_dist_point_line.txt
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Testsuite from file tests/check_min_dist_point_line.txt.
-Command string: line a=1 b=2 c=3
-fewfeewfewfewf
-objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-arguments: ['a=1', 'b=2', 'c=3']
-object_name: line
-{'a': '1', 'b': '2', 'c': '3'}
-*arguments_thing : {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-bullshit: {'a': '1', 'b': '2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-objects at the end: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: point
-fewfeewfewfewf
-arguments: []
-object_name: point
-{}
-*arguments_thing : {}
-bullshit: {}
-bullshit: {}
-the_object.name == point0
-setting parameter x to this: x0
-the_object.name == point0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-objects after creation of new_object : ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline']
-gregregregrr
-global_objects at the start: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-global_objects after appending new_object: ['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'point0']
-Command result: 0
-Command string: point0.name = mypoint
-thing
-==================================================================================
-Setting property : name
-On object: point0
-selected_property: name
-value: mypoint
-result: None
-Command string: mypoint.set_point_to_values 0 0
-thing
-bullshitrgregreg
-command: mypoint.set_point_to_values 0 0
-self.method_arg_types : [['float', 'float'], []]
-self.method_arg_types : [['float', 'float'], []]
-SHITSHITSHIT
-self.x == 0.0
-self.y == 0.0
-x_in: 0.0
-y_in: 0.0
-result: 0
-Command string: mindistpointobjdot myline mypoint
-fewfeewfewfewf
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-dot_thing: =======================
-Type: point
-x = 0.0
-y = 0.0
-name = mypoint
-=======================
-
-object_thing: =======================
-Type: line
-a = 1
-b = 2
-c = 3
-name = myline
-=======================
-		
-oof
-oof22
-object_equation : [Eq(x + 2*y + 3, 0)]
-[x + 2*y + 0 + 3]
-[x]
-[x + 2*y + 0 + 3]
-[x]
-[[x + 2*y + 0 + 3]]
-[-2*y - 3, x]
-Matrix([[1, -2*y - 3]])
-[x + 2*y + 0 + 3]
-[y]
-[x + 2*y + 0 + 3]
-[y]
-[[x + 2*y + 0 + 3]]
-[-x/2 - 3/2, y]
-Matrix([[2, -x - 3]])
-sol_x : {x: -2*y - 3}
-sol_y : {y: -x/2 - 3/2}
-substitution: {x: -2*y - 3, y: -x/2 - 3/2}
-thing: {x: -2*y - 3, y: -x/2 - 3/2}
-bullshit ooof :::: sqrt((x-0.0)**2+(y-0.0)**2)
-distance_function : sqrt(x**2 + y**2)
-Substituted distance function: sqrt(x**2 + (-x/2 - 3/2)**2)
-f: sqrt(x**2 + (-x/2 - 3/2)**2)
-solution: 3*sqrt(5)/5
-distance_function : sqrt(x**2 + (-x/2 - 3/2)**2)
-Minimum distance: 3*sqrt(5)/5
-name_str: mypoint
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-name_str: myline
-['myline1', 'myline2', 'mypoint', 'myline1', 'line1', 'line2', 'myline2', 'mypoint', 'myline', 'mypoint', 'triangle0', 'mycircle', 'mypoint', 'circle1', 'myline', 'mypoint', 'linefirst', 'linesecond', 'triangle1', 'myline', 'line3', 'myline', 'mypoint']
----------------------------
-myline1
-myline2
-mypoint
-myline1
-line1
-line2
-myline2
-mypoint
-myline
-mypoint
-triangle0
-mycircle
-mypoint
-circle1
-myline
-mypoint
-linefirst
-linesecond
-triangle1
-myline
-line3
-myline
-mypoint
----------------------------
-obj.name == myline1
-obj.name == myline2
-obj.name == mypoint
-obj.name == myline1
-obj.name == line1
-obj.name == line2
-obj.name == myline2
-obj.name == mypoint
-oof
-oof22
-radiuses : 3*sqrt(5)/5
-Returning this: (x-0.0)**2+(y-0.0)**2=(3*sqrt(5)/5)**2
-circle_equation : [Eq(x**2 + y**2, 9/5)]
-all equations: [Eq(x + 2*y + 3, 0), Eq(x**2 + y**2, 9/5)]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]
-[x, y]
-[[x + 2*y + 0 + 3, x**2 + y**2 - 9/5]]
-[-3, x + 2*y]
-[9/5, x**2 + y**2]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-[Poly(x + 2*y + 3, x, y, domain='ZZ'), Poly(5*x**2 + 5*y**2 - 9, x, y, domain='ZZ')]
-Result: [(-3/5, -6/5)]
-Resulting dict: {'x': -3/5, 'y': -6/5}
-oofstring1: -3/5
-oofstring2: -6/5
-oofstring1 after: -3/5
-oofstring2 after: -6/5
-final_dict: {'x': '-3/5', 'y': '-6/5'}
-Command result: {'x': '-3/5', 'y': '-6/5'}
-Command string: quit
-"quit" encountered in testsuite. Checking answer:
-The output of the last command: {'x': '-3/5', 'y': '-6/5'}
-Expected final result: {'x': '-3/5', 'y': '-6/5'}
-command_result: {'x': '-3/5', 'y': '-6/5'}
-expected_result: {'x': '-3/5', 'y': '-6/5'}
-[92mTestsuite tests/check_min_dist_point_line.txt passed![0m
-results list: [True, True, True, True, True, True, True, True, True, True, False, True]
-[94m=================================================
-
-[0m
-[94mFinal results: 
-[0m
-[92mTest: tests/check_var_assignment_to_function_result.txt PASSED![0m
-[92mTest: tests/check_line_intersect.txt PASSED![0m
-[92mTest: tests/check_var_subsequences.txt PASSED![0m
-[92mTest: tests/check_max_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_intersection_triangle_circle.txt PASSED![0m
-[92mTest: tests/check_integral.txt PASSED![0m
-[92mTest: tests/check_point_on_circle.txt PASSED![0m
-[92mTest: tests/check_min_output_dot_line.txt PASSED![0m
-[92mTest: tests/check_lines_angle.txt PASSED![0m
-[92mTest: tests/check_line_triangle_intersection.txt PASSED![0m
-[91mTest: tests/check_area_between_intersections.txt FAILED![0m
-[92mTest: tests/check_min_dist_point_line.txt PASSED![0m
-
-
-
-[91mSome tests failed!
-
-[0m
-[94m=================================================[0m
diff --git a/uuuu.txt b/uuuu.txt
deleted file mode 100644
index e66c005..0000000
--- a/uuuu.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-[{'x': 0.648031893339682, 'y': 0.141338648889947}, {'x': 0.523076923076923, 'y': 0.284615384615385}, {'x': 0.800000000000000, 'y': 0.700000000000000}, {'x': 1.00000000000000, 'y': 0.176393202250021}, {'x': 1.00000000000000, 'y': 0.623606797749979}]
-
-
-{'x': 0.648031893339682, 'y': 0.141338648889947}
-{'x': 0.523076923076923, 'y': 0.284615384615385}
-{'x': 0.800000000000000, 'y': 0.700000000000000}
-{'x': 1.00000000000000, 'y': 0.176393202250021}
-{'x': 1.00000000000000, 'y': 0.623606797749979}
-
-
diff --git a/variable_assignment_backup.txt b/variable_assignment_backup.txt
deleted file mode 100644
index eef931d..0000000
--- a/variable_assignment_backup.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-line a=1 b=2 c=3
-line0.name = myline1
-line a=4 b=5 c=6
-line0.name = myline2
-myvar := intersect myline1 myline2
-quit
diff --git a/wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww.py b/wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww.py
deleted file mode 100644
index 9fbe756..0000000
--- a/wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww.py
+++ /dev/null
@@ -1,1178 +0,0 @@
-
-
-import numpy as np
-import sympy
-from sympy.parsing.sympy_parser import parse_expr
-import sys
-from sympy.solvers import solve
-from sympy import Symbol
-from sympy import Eq
-from sympy import *
-from outcolors import *
-import readline
-
-global_things = []
-global_objects = []
-
-commands = ["line", "intersect", "help", "quit", "objects", "point"]
-
-object_types = ["line", "circle", "point"] # these are the types for when the argument to a method of an object are themselves objects. If not, then they are assumed to be constant values.
-
-VERSION_STR="1.0"
-
-class bcolors:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-def warn(string):
-	print(bcolors.WARNING + "Warning: " + str(string) + bcolors.ENDC)
-	return
-
-def fail(string):
-	print_col(bcolors.FAIL, "Error: " + str(string))
-	return
-
-
-
-class point:
-
-	def __init__(self, *arguments):
-
-		self.debug = False
-		self.default_arguments = {"x":"unknown", "y":"unknown", "name":"point"}
-
-		self.methods = [self.set_point_to_values, self.get_equations]
-		self.method_strings = ["set_point_to_values", "get_equations"]
-		self.method_arg_types = [["float", "float"], []]
-		self.num_args = [2, 0]
-		self.parameters = ["x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-	def set_point_to_values(self, x_in, y_in):
-		print("SHITSHITSHIT")
-		#self.x = self.x.subs({"x":x_in})
-		#self.y = self.y.subs({"y":y_in})
-		
-		self.x = x_in
-		self.y = y_in
-
-		print("self.x == "+str(self.x))
-		print("self.y == "+str(self.y))
-
-		print("x_in: "+str(x_in))
-		print("y_in: "+str(y_in))
-
-		return 0
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-	def replace_equation_shit(self):
-		return ["x="+str(self.x), "y="+str(self.y)]
-
-	def get_equations(self):
-
-		
-
-
-
-
-		left_side_1 = "x"
-		left_side_2 = "y"
-		right_side_1 = self.x
-		right_side_2 = self.y
-			
-		equation_stuff = self.replace_equation_shit()
-
-		paskaoof = []
-
-		equation1 = equation_stuff[0]
-		equation2 = equation_stuff[1]
-
-		left_side_1 = equation1[:equation1.index("=")]
-		right_side_1 = equation1[equation1.index("=")+1:]
-
-		left_side_2 = equation2[:equation2.index("=")]
-		right_side_2 = equation2[equation2.index("=")+1:]
-
-
-		print("left_side_1 : "+str(left_side_1))
-
-		print("right_side_1 : "+str(right_side_1))
-
-		
-
-		first_equation = Eq(parse_expr(left_side_1), parse_expr(str(right_side_1)))
-		second_equation = Eq(parse_expr(left_side_2), parse_expr(str(right_side_2)))
-		
-		print("first_equation : "+str(first_equation))
-		print("second_equation : "+str(second_equation))
-		
-		#second_equation = str(left_side_2)+"="+str(right_side_2)
-
-		#print("first_equation : "+str(first_equation))
-
-		equation_list = [first_equation, second_equation]
-		#equation_list = [Eq(left_side_1, self.x), Eq(left_side_2, self.y)]
-		return equation_list
-	def __str__(self):
-		
-		return '''=======================\nType: point\nx = {}\ny = {}\nname = {}\n=======================\n'''.format(self.x, self.y, self.name)
-
-
-
-
-
-
-	
-		
-
-def get_object_by_name(name_str):
-	print("name_str: " + str(name_str))
-	print(get_names(global_objects))
-	count = 0
-	obj = global_objects[0]
-
-	print("---------------------------")
-	for object_thing in global_objects:
-		print(object_thing.name)
-	print("---------------------------")
-
-	while obj.name != name_str and count != len(global_objects):
-		print("obj.name == " + str(obj.name))
-		count += 1
-		obj = global_objects[count]
-
-		
-
-
-	if count == len(global_objects):
-		# object by that name does not exist
-		fail("Object of name "+str(name_str)+" does not exist.")
-		return 1
-	return obj
-
-
-
-def common_arg_stuff(the_object, *arguments_thing):
-	
-	count = 0
-	print("*arguments_thing : " + str(*arguments_thing))
-
-	default_arguments = the_object.default_arguments
-	
-	# assume default arguments first, and then replace the overridden arguments afterwards
-	final_arguments = default_arguments
-	bullshit = str(*arguments_thing)
-	print("bullshit: "+str(bullshit))
-
-	# ==============================
-
-	# refer to this: https://stackoverflow.com/questions/17610732/error-dictionary-update-sequence-element-0-has-length-1-2-is-required-on-dj
-
-	#bullshit2 = dict(bullshit)   # this shit wont work, because reasons and spagetti code. We must use the *VERY SAFE* function "eval" :)
-	bullshit2 = eval(bullshit)
-	
-	# ==============================
-
-	print("bullshit: "+str(bullshit2))
-	for argument in bullshit2.keys():
-		final_arguments[argument] = bullshit2[argument]
-
-	name = final_arguments["name"]
-	while str(name)+str(count) in get_names(global_objects):
-		count += 1
-	if count or name == the_object.default_arguments["name"]:
-		the_object.name = str(name)+str(count)
-		the_object.var_count = count
-	else:
-		the_object.name = name
-		the_object.var_count = count
-
-	# run through the rest of the arguments and set the appropriate values for each of the parameters for the object:
-
-	# this next loop is here to set the variables of the object to an unknown value. The values (if specified) are set in the later loop.
-
-	for param in the_object.parameters:
-		# self.a = Symbol('a'+str(count))
-		print("the_object.name == "+str(the_object.name))
-		print("setting parameter "+str(param)+" to this: "+str(str(param)+str(count)))
-		setattr(the_object, str(param), Symbol(str(param)+str(count)))
-		#setattr(the_object, str(Symbol(str(param)+str(count))), str(param))
-
-	# if a value is mentioned specifically,then set the value of the variable to that.
-
-	for param in the_object.parameters:
-		if param in final_arguments:
-			# the parameter is specified in arguments
-			if final_arguments[param] != "unknown": # the variable is actually specified
-				# self.a = Symbol('a'+str(count))
-				setattr(the_object, str(param), final_arguments[param])
-		#else:
-		#	setattr(the_object, str(param), final_arguments[param])  # this was done in the earlier loop
-	print("Names of global objects at the end of common_arg_stuff: " + str(get_names(global_objects)))
-
-class line:
-	#def __init__(self,a="unknown",b="unknown",c="unknown", name="line"):
-	def __init__(self,*arguments):
-
-		#name_str = name+str(self.var_count)
-
-		# a*x+b*x=c
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations, self.noop]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations", "noop"] # the noop is just for sanity testing
-		self.method_arg_types = [["point", "point"], ["point", "point"], [], []]
-
-		self.num_args = [2,2,0,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-
-
-		common_arg_stuff(self, *arguments)
-		'''
-		count = 0
-		while str(name)+str(count) in get_names(global_objects):
-			count += 1
-		if count:
-
-			self.name = str(name)+str(count)
-			self.var_count = count
-		else:
-			self.name = name # there were no duplicates so just set the name as name
-			self.var_count = count
-
-
-		if name == "line":
-			
-			print("self.var_count : " + str(self.var_count))
-			print("name: " + str(name))
-
-			name_str = name+str(self.var_count)
-			print("name_str : " + str(name_str))
-
-			self.name = name_str
-		else:
-			self.name = name
-
-
-		
-
-
-		self.a = Symbol('a'+str(count))
-		self.b = Symbol('b'+str(count))
-		self.c = Symbol('c'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if a != "unknown":
-			self.a = a
-		if b != "unknown":
-			self.b = b
-		if c != "unknown":
-			self.c = c
-
-		'''
-
-	def noop(self):
-
-		return 0
-
-	def set_values_point_line(point, line_vector):
-		
-		# this basically gets the appropriate values for a,b,c when the line goes through point and steps from there to line_vector from point
-
-		# basically assume that c=1
-
-		#self.c_val = 1
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector[0]
-		xy=line_vector[1]
-		
-		x0 = point[0]
-		x1 = point[1]
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-		self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		self.b = simplify(xv/(x0*yv-xv*y0))
-
-		#self.c = float(self.c)
-		#self.a = float(self.a)
-		#self.b = float(self.b)
-		return;
-
-	def set_values_two_points(self, point1, point2):
-
-		# get vector from point1 to point2
-
-		#from1to2 = -1*point1+point2
-
-
-		print("==========================================")
-
-
-		print("point1.x : "+str(point1.x) + " point1.y: "+str(point1.y))
-		print("point2.x : "+str(point2.x) + " point2.y: "+str(point2.y))
-
-
-		print("==========================================")
-
-		print("-1*point1.x+point2.x == " + str(-1*point1.x+point2.x))
-		print("-1*point1.x == " + str(-1*point1.x))
-		print("type(point1.x) == "+str(type(point1.x)))
-
-
-		point1.x = float(point1.x)
-		point1.y = float(point1.y)
-		point2.x = float(point2.x)
-		point2.y = float(point2.y)
-
-		line_vector_x = -1*point1.x+point2.x
-		line_vector_y = -1*point1.y+point2.y
-
-		#line_vector_x = point2.x
-
-		#line_vector_y = point2.y
-
-		#self.set_values_point_line(point1, from1to2)
-
-
-		self.c = 1
-		'''
-		xv = line_vector.item(0)
-		xy=line_vector.item(1)
-		
-		x0 = point.item(0)
-		x1 = point.item(1)
-		'''
-
-		xv = line_vector_x
-		yv= line_vector_y
-
-		print("xv: "+str(xv))
-		print("yv: "+str(yv))
-		print("0000000")
-
-		
-		x0 = point1.x
-		#x1 = point1.y
-		y0 = point1.y
-
-		x1 = xv
-
-
-		# a = -(yv/(x0*yv-xv*y0))
-		# b = xv/(x0*yv-xv*y0)
-
-
-		print("yv: " + str(yv))
-		print("x0: "+str(x0))
-		print("xv: "+str(xv))
-		print("y0: "+str(y0))
-		string_oof_1 = "-({}/({}*{}-{}*{}))".format(yv, x0, yv, xv, y0)
-		
-		# xv/(x0*yv-xv*y0)
-		
-
-		print(string_oof_1)
-
-
-		# (y0-y1)/(x0*y1-x1*y0)
-
-		# -yv/(x0*yv-xv*y0)
-
-
-
-		self.a = sympy.simplify(string_oof_1)
-
-		string_oof_2 = "{}/({}*{}-{}*{})".format(xv, x0, yv, xv, y0)
-
-		self.b = sympy.simplify(string_oof_2)
-		#self.a = simplify(-(yv/(x0*yv-xv*y0)))
-		#self.b = simplify(xv/(x0*yv-xv*y0))
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		equation = "("+str(self.a)+")*"+str(self.x)+"+("+str(self.b)+")*"+str(self.y)+"+("+str(self.c)+")"
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation)
-		print("oof")
-		equation_right_side = parse_expr(right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-	def __str__(self):
-		return_string = '''=======================\nType: line\na = {}\nb = {}\nc = {}\nname = {}\n=======================
-		'''.format(self.a, self.b, self.c, self.name)
-		return return_string
-
-	def run_method_on_self(self,method_string, command, attribute_name): # attribute_name actually does not get even used :=)
-		# global_objects
-		print("bullshitrgregreg")
-		print("command: "+str(command))
-		command_string = command
-		arguments = command_string.split(" ")[1:]
-
-		if method_string not in self.method_strings:
-			fail("Invalid method : "+str(method_string))
-			return 1
-
-		# self.method_arg_types = [["point", "point"], ["point", "point"], []]
-		correct_method_index = self.method_strings.index(method_string)
-		correct_method = self.methods[correct_method_index]
-		arguments_for_method = []
-		
-		#for i in range(self.num_args[self.num_args.index(correct_method_index)]):
-		for i in range(self.num_args[correct_method_index]):
-			# get the arguments
-			print("self.method_arg_types : " + str(self.method_arg_types))
-			if self.method_arg_types[correct_method_index][i] in object_types:
-				object_name = arguments[i]
-				object_itself = get_object_by_name(object_name)
-
-				arguments_for_method.append(object_itself)
-			else:
-				# assumed to be a constant:
-				arguments_for_method.append(float(arguments[i]))
-
-		# call the method with the arguments:
-
-		return_value = correct_method(*arguments_for_method)
-		
-
-		return return_value
-
-
-		'''
-		args = command.split(" ")[1:]
-
-		if len(args) != self.num_args[self.num_args.index(method_string)]:
-			fail("Invalid number of arguments for method "+str(method_string)+" on object named "+str(self.name))
-
-
-		if method_string == "set_values_point_line":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_point_line(point1, point2) # the line vector is basically a point
-
-			return 0
-
-		if method_string == "set_values_two_points":
-			obj1_name = args[0]
-			obj2_name = args[1]
-			point1 = get_object_by_name(obj1_name)
-			point2 = get_object_by_name(obj2_name)
-			if point1 == 1 or point2 == 1:
-				return 1
-			self.set_values_two_points(point1, point2)
-			return 0
-		
-		'''
-
-
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-		setattr(self, selected_property, value)
-		return 0
-
-
-
-
-
-
-
-class circle:
-
-	#def __init__(self, xc="unknown", yc="unknown", r="unknown", name="circle"):
-	def __init__(self, *arguments):
-		self.debug=False
-
-		
-
-
-		self.default_arguments = {"xc":"unknown", "yc":"unknown", "r":"unknown", "name":"circle"}
-		self.methods = [self.replace_equation_shit, self.get_equations]
-		self.method_strings = ["replace_equation_shit", "get_equations"]
-
-		self.num_args = [0,0]
-		self.parameters = ["xc", "yc", "r", "x", "y"]
-
-		common_arg_stuff(self, *arguments)
-
-		'''
-
-		self.debug=False
-		self.default_arguments = {"a":"unknown", "b":"unknown", "c":"unknown", "name":"line"}
-
-		self.methods = [self.set_values_point_line, self.set_values_two_points, self.get_equations]
-		self.method_strings = ["set_values_point_line", "set_values_two_points", "get_equations"]
-		self.num_args = [2,2,0]  # these are strict number of arguments for each method
-		self.parameters = ["a","b","c","x","y"]
-		'''
-		
-
-
-		'''
-		count = 0
-		while str(count) in global_things:
-			count += 1
-		self.var_count = count
-		if name == "circle":
-			name_str = name+str(self.var_count)
-			self.name = name_str
-		else:
-			self.name = name
-		
-
-
-		self.xc = Symbol('xc'+str(count))
-		self.yc = Symbol('yc'+str(count))
-		self.r = Symbol('r'+str(count))
-
-		self.x = Symbol('x'+str(count))
-		self.y = Symbol('y'+str(count))
-		if xc != "unknown":
-			self.xc = xc
-		if yc != "unknown":
-			self.yc = yc
-		if r != "unknown":
-			self.r = r
-
-		'''
-
-	def replace_equation_shit(self):
-		print("Circle equation bullshit: ")
-		print(str("(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"))
-		return "(("+"x"+")-("+str(self.xc)+"))**2+(("+"y"+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-		#return "(("+str(self.x)+")-("+str(self.xc)+"))**2+(("+str(self.y)+")-("+str(self.yc)+"))**2=("+str(self.r)+")**2"
-
-
-
-	def get_equations(self):
-		# returns the line in the a*x+b*y+c = 0 format
-		#equation = "((x)-(xc))**2+((y)-(yc))**2=(r)**2"
-		thing = self.replace_equation_shit()
-
-		equation_left_side = thing[:thing.index("=")]
-		equation_right_side = thing[thing.index("=")+1:]
-
-
-		right_side = "0"
-		if self.debug:
-			print(equation)
-		equation_left_side = parse_expr(equation_left_side)
-		print("oof")
-		equation_right_side = parse_expr(equation_right_side)
-		print("oof22")
-		#return parse_expr(equation_left_side),parse_expr(equation_right_side) 
-		return [Eq(equation_left_side, equation_right_side)]
-
-	def set_property_on_self(self,selected_property, value):
-
-
-		# thanks to https://stackoverflow.com/questions/2612610/how-to-access-get-or-set-object-attribute-given-string-corresponding-to-name-o
-		# stackoverflow username @pratik-deoghare
-		# setattr(t, 'attr1', 21)
-		print("selected_property: "+str(selected_property))
-		print("value: "+str(value))
-
-		print("self.yc : "+str(self.yc))
-		setattr(self, selected_property, value)
-		return 0
-	def __str__(self):
-		return_string = '''=======================\nType: circle\nx0 = {}\ny0 = {}\nr = {}\nname = {}\n=======================
-		'''.format(self.xc, self.yc, self.r, self.name)
-		return return_string
-
-
-
-
-
-
-
-
-def intersection(object1, object2):
-
-	# object is assumed to have the get_equation method which returns the equation which describes the object (like a line is a*x+b*y+c=0 )
-	print("================================================")
-	print("object1 : " + str(object1))
-	print("object2 : " + str(object2))
-	print("object1 : " + str(type(object1)))
-	print("object2 : " + str(type(object2)))
-	print("================================================")
-	equations1 = object1.get_equations()
-
-	equations2 = object2.get_equations()
-
-
-
-	results = []
-	'''
-	for equation1, equation2 in zip(equations1, equations2):
-
-
-
-
-		temp_var_x = Symbol("tempvarx")
-		temp_var_y = Symbol("tempvary")
-
-		#substitute_first = {object1.x:temp_var_x, object1.y:temp_var_y}
-		#substitute_second = {object2.x:temp_var_x, object2.y:temp_var_y}
-
-		#substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x":temp_var_x, "y":temp_var_y}
-
-
-		substitute_first = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-		substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-
-
-
-		print("substitute_first : " + str(substitute_first))
-
-		equation1 = equation1.subs(substitute_first)
-
-		equation2 = equation2.subs(substitute_second)
-
-		print("-----------")
-		print(equation1)
-		print(equation2)
-		print("-----------")
-		print(temp_var_x)
-		print(temp_var_y)
-
-		result = sympy.solve((equation1, equation2), (temp_var_x, temp_var_y))
-
-		print("result: "+str(result))
-		results.append(result)
-	'''
-
-	temp_var_x = Symbol("tempvarx")
-	temp_var_y = Symbol("tempvary")
-
-	substituted_equations = []
-
-
-	print("bullshit")
-	for equation in equations1:
-		print("equation : "+str(equation))
-		print("\"x\"+str(object1.var_count) == " + str("x"+str(object1.var_count)))
-		substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-	for equation in equations2:
-
-		substitute_first = {"x":temp_var_x, "y":temp_var_y}
-		#substitute_second = {"x"+str(object1.var_count):temp_var_x, "y"+str(object1.var_count):temp_var_y}
-
-		equation1 = equation.subs(substitute_first)
-		substituted_equations.append(equation1)
-
-
-	print("substituted_equations")
-	for eq in substituted_equations:
-		print(str(eq))
-
-	print()
-	result = sympy.solve(substituted_equations, (temp_var_x, temp_var_y))
-	print("result: "+str(result))
-
-	return result
-
-
-
-
-def debug_tests():
-
-	# self,a=0,b=0,c=0
-
-	line_object = line(a=10, b=4, c=3)
-	line_object.debug = True
-	result = line_object.get_equations()
-	#print("here is the result: "+str(result))
-	#x = Symbol('x')
-	#print("thing")
-	#print(line_object.get_equation()[0])
-	#print("thingooff")
-	#print(solve(line_object.get_equation(), line_object.y))
-	#line_object2 = line(a=11, b=4, c=3)
-	#thingoof = intersection(line_object, line_object2)
-	line_object2 = line(a=11, b=4, c=3)
-	
-	# x0="unknown", y0="unknown", r="unknown"
-
-	circle_object = circle(xc=1,yc=3, r=10)
-
-
-	thingoof = intersection(line_object, circle_object)
-
-	print("thingoof: " + str(thingoof))
-
-
-	return 0
-
-
-
-
-def print_banner():
-	print("Welcome to geometrylib "+str(VERSION_STR) + " !")
-	print("Type \"help\" for help menu.")
-
-def print_col(color, string):
-	print(color + string + bcolors.ENDC)
-	return
-
-def set_attributes(object, attributes):
-
-	print("attribute thing: " + str(attributes))
-
-
-	for attribute_setting in attributes:
-		# these arguments are of the format attribute=value
-
-		if "=" not in attribute_setting:
-			fail("= character must be in arguments. For example \"line a=1 b=2 c=3\" would create a line of the form 1*x+2*y+c=0 .")
-			return 1
-		pair = attribute_setting.split("=")
-		value = pair[1]   # my_string.replace('.', '', 1).isdigit()
-		if value.replace('.', '', 1).isdigit():
-
-			value = float(value)
-		
-		attribute = pair[0]
-		print("poopoopoopoopoopoo")
-		print("object.name: "+str(object.name))
-		print("attribute: "+str(attribute))
-		print("value: "+str(value))
-		setattr(object, attribute, value)
-
-def common_object_creation_stuff(arguments, object_name, objects):
-	# first create the dictionary from the arguments
-
-	arg_dict = dict([thing.split("=")[0], thing.split("=")[1]] for thing in arguments)
-	print(arg_dict)
-
-	#  globals()["line"]
-	#  thanks to https://stackoverflow.com/questions/3451779/how-to-dynamically-create-an-instance-of-a-class-in-python
-	# stackoverflow username @elewinso
-	
-	if object_name not in globals().keys():
-		fail("Class named "+str(object_name)+" does not exist.")
-		return 1
-
-	new_object = globals()[object_name](arg_dict) # create the object
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after creation of new_object : " + str(get_names(objects)))
-	objects.append(new_object)
-	print("gregregregrr")
-	print("global_objects at the start: " + str(get_names(global_objects)))
-	print("objects after appending new_object: " + str(get_names(objects)))
-	#global_objects.append(new_object)
-	print("global_objects after appending new_object: " + str(get_names(global_objects)))
-	return 0
-
-
-
-
-
-def line_command(command:str, objects:list):
-	
-	#new_line = line()
-
-	args = command.split(" ")
-	args = args[1:]
-	#print("args : "+str(args))
-	#if set_attributes(new_line, args):
-		#return 1
-
-	# common_object_creation_stuff(arguments, object_name, objects):
-	print("objects at the start: "+str(get_names(objects)))
-
-	common_object_creation_stuff(args, "line", objects)
-	print("objects at the end: "+str(get_names(objects)))
-
-
-	print_col(bcolors.OKGREEN, "Created new object.")
-	#print(new_line)
-
-	#objects.append(new_line)
-	#global_objects.append(new_line)
-	return 0
-
-def point_command(command:str, objects:list):
-
-	args = command.split(" ")
-	args = args[1:]
-
-	common_object_creation_stuff(args, "point", objects)
-
-	return 0
-
-
-
-
-def circle_command(command:str, objects: list):
-	args = command.split(" ")
-	args = args[1:]
-	common_object_creation_stuff(args, "circle", objects)
-	print_col(bcolors.OKGREEN, "Created new object.")
-	return 0
-
-def help_command(command:str, objects:list):
-	print_col(bcolors.OKCYAN, "Current commands: ")
-	for comm in commands:
-		print_col(bcolors.BOLD, comm)
-	return
-
-
-def get_names(object_list):
-	return [obj.name for obj in object_list]
-
-
-
-def intersection_command(command:str, objects:list):
-	args = command.split(" ")
-	print("Args : "+str(args))
-	args = args[1:]
-
-	
-	obj_name1 = args[0]
-	obj_name2 = args[1]
-	
-	print("obj_name1 : "+str(obj_name1))
-	print("obj_name2 : "+str(obj_name2))
-
-	obj1 = get_object_by_name(obj_name1)
-	obj2 = get_object_by_name(obj_name2)
-	print("poopooo")
-	print("obj1: "+str(obj1))
-	print("obj2: "+str(obj2))
-	results = intersection(obj1, obj2)
-	if results == []:
-		print_col(CYELLOW, "Objects do not intersect.")
-	else:
-		print_col(CYELLOW, "Objects intersect atleast at one point.")
-
-		print_col(CYELLOW, "Intersections are at points: " + str(results))
-
-	return 0
-
-
-
-
-	#obj_names = get_names(objects)
-
-	#print("obj_names : " + str(obj_names))
-	# get_object_by_name(name_str)
-
-
-
-
-
-	return
-
-def invalid_command(command):
-	print_col(bcolors.FAIL, "Invalid command: " + str(command))
-	return
-
-
-def quit_command(*args):
-	print_col(bcolors.OKGREEN, "Thank you for using geometrylib! See you again soon!")
-	exit(0)
-
-
-def check_common_syntax(command_string, max_args, min_args, all_commands):
-	print("fewfeewfewfewf")
-
-	# this part is shared by every command (checks that the correct number of arguments are passed to the function)
-
-	index = all_commands.index(command_string.split(" ")[0])
-	
-	stuff = command_string.split(" ")
-	stuff = stuff[1:]
-	max_num_args = max_args[index]
-	min_num_args = min_args[index]
-
-	if len(stuff) > max_num_args or len(stuff) < min_num_args:
-		fail("Invalid number of arguments: "+str(command_string))
-		fail("Min number of arguments is "+str(min_num_args) + " and max number of arguments is "+str(max_num_args) + " .")
-		return 1
-	return 0
-
-
-def objects_command(command_string, objects):
-	print_col(CYELLOW, "Here are all of the objects generated so far: ")
-	for obj_name in get_names(objects):
-		print_col(CBLUE, obj_name)
-	return 0
-
-
-
-def run_method(obj, command_string, attribute_name):
-	# method = getattr(emp1, 'get_name', None)
-
-	things = command_string.split(" ")
-	
-	args = things[1:]
-	method_str = things[0].split(".")[1] # the method is after the dot
-
-	
-	return_value = obj.run_method_on_self(method_str, command_string, attribute_name)
-	#function = getattr(obj, method_str, None)
-	return return_value
-
-
-def set_property(obj, command_string):
-
-	things = command_string.split(" ")
-
-
-
-	if things[0].count(".") > 1:
-		fail("There can only be one dot in command when setting property of an object.")
-		return 1
-
-	selected_property = things[0].split(".")[1]
-
-	if things[1] != "=":
-		fail("Called set_property with this command \""+str(command_string)+"\" the second operand must be \"=\" . For example myline.name = newname.")
-		return 1
-
-	value = things[2]
-
-	obj.set_property_on_self(selected_property, value)
-
-	return
-
-
-
-
-
-
-
-
-
-
-def check_method_command(command_string, all_objects):
-
-	# check if the command is trying to run a method on an object
-
-	obj_dot_method = command_string.split(" ")[0]
-
-	obj_name = obj_dot_method.split(".")[0]
-	
-	attr_name = obj_dot_method.split(".")[1]
-
-	if obj_name not in get_names(all_objects):
-		fail("Object "+str(obj_name)+" does not exist currently.")
-		return 1
-
-	correct_index = get_names(all_objects).index(obj_name)
-	correct_object = all_objects[correct_index]
-
-	# now check that the attribute exists and that it is callable (aka a function).
-
-	if not hasattr(correct_object, attr_name):
-		fail("Object "+str(obj_name)+" does not have the attribute "+str(attr_name))
-		return 1
-	if not callable(getattr(correct_object, attr_name)):
-		# assume that the attribute is just a property
-		print("==================================================================================")
-		print("Setting property : "+str(attr_name))
-		print("On object: "+str(correct_object.name))
-		return set_property(correct_object, command_string)   # if returns 1, then failure (for example property does not exist for object) otherwise 0
-			
-	else:
-		# is callable:
-		return run_method(correct_object, command_string, attr_name)
-
-def print_object(obj):
-	print(obj)
-	return 0
-
-
-
-
-def command_mainloop(file=None):
-	print_banner()
-	line_counter = 0
-	lines = []
-	if file:
-		fh = open(file, "r")
-		lines = fh.readlines()
-		fh.close()
-		for i in range(len(lines)):
-			lines[i] = lines[i][:-1]
-		print("Running commands from file "+str(file)+".")
-
-	objects = []
-	commands = ["line", "intersect", "help", "quit", "objects", "circle", "point"]
-	min_arg_lengths = [0,0,0,0,0,0,0]
-	max_arg_lengths = [3,2,0,0,0,3,2]
-	handle_functions = [line_command, intersection_command, help_command, quit_command, objects_command, circle_command, point_command]
-	while True:
-		if line_counter != len(lines):
-			command_string = lines[line_counter]
-			line_counter += 1
-			print("Command string: " + str(command_string))
-		else:
-			command_string = str(input(bcolors.OKBLUE + ">>> " + bcolors.ENDC))
-			#command_string = "line a=1 b=2 c=3"
-
-		command_start = command_string.split(" ")[0]
-		if command_start not in commands:
-			if command_start != "":
-				print("thing")
-				if len(command_string.split(" ")) == 1 and "." not in command_string.split(" ")[0]:
-					# if the user types just the object name, then print object as string
-					if command_start in get_names(global_objects):
-						print_object(get_object_by_name(command_start))
-						continue
-					invalid_command(command_string)
-					continue
-				
-
-
-				# first assume that the command is an attempt to run a method on an object:
-
-				result = check_method_command(command_string, global_objects)
-				print("result: "+str(result))
-				if result: # 0 means success, 1 means failure
-					invalid_command(command_string)
-			continue
-
-		index = commands.index(command_start)
-		result = check_common_syntax(command_string, max_arg_lengths, min_arg_lengths, commands)  # this check is shared by every command to check the arguments
-		if result:
-			continue
-
-		handle_functions[index](command_string, global_objects)
-
-
-
-		#global_objects = 
-
-
-
-
-
-
-
-
-
-
-
-
-if __name__=="__main__":
-	'''
-
-
-	if sys.argv[-1] == "--test":
-		debug_tests()
-		exit(0)
-	'''
-
-	if "--file" in sys.argv:
-		filething = sys.argv[sys.argv.index("--file")+1]
-	else:
-		filething = None
-
-	command_mainloop(file=filething)
-
-
-
-
-
-
-	
-
-
-		
-
-
-
-
diff --git a/yyy.txt b/yyy.txt
deleted file mode 100644
index a966a22..0000000
--- a/yyy.txt
+++ /dev/null
@@ -1,77 +0,0 @@
-Welcome to geometrylib 1.0 !
-Type "help" for help menu.
-Running commands from file ./tests/check_area_between_intersections.txt.
-Command string: 
-Command string: line a=4 b=-2 c=3
-fewfeewfewfewf
-objects at the start: []
-arguments: ['a=4', 'b=-2', 'c=3']
-object_name: line
-{'a': '4', 'b': '-2', 'c': '3'}
-*arguments_thing : {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-bullshit: {'a': '4', 'b': '-2', 'c': '3'}
-the_object.name == line0
-setting parameter a to this: a0
-the_object.name == line0
-setting parameter b to this: b0
-the_object.name == line0
-setting parameter c to this: c0
-the_object.name == line0
-setting parameter x to this: x0
-the_object.name == line0
-setting parameter y to this: y0
-Names of global objects at the end of common_arg_stuff: []
-global_objects at the start: []
-objects after creation of new_object : []
-gregregregrr
-global_objects at the start: ['line0']
-objects after appending new_object: ['line0']
-global_objects after appending new_object: ['line0']
-objects at the end: ['line0']
-[92mCreated new object.[0m
-Command result: 0
-Command string: line0.name = myline
-thing
-==================================================================================
-Setting property : name
-On object: line0
-selected_property: name
-value: myline
-result: None
-Command string: area_between_intersections myline y=x**2-10*x+10
-fewfeewfewfewf
-name_str: myline
-['myline']
----------------------------
-myline
----------------------------
-oof
-oof22
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]
-[x, y]
-[[4*x - 2*y + 0 + 3, -x**2 + 10*x + y - 10]]
-[-3, 4*x - 2*y]
-[10, -x**2 + 10*x + y]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-[Poly(4*x - 2*y + 3, x, y, domain='ZZ'), Poly(-x**2 + 10*x + y - 10, x, y, domain='ZZ')]
-intersection_points == [(6 - sqrt(110)/2, 27/2 - sqrt(110)), (sqrt(110)/2 + 6, sqrt(110) + 27/2)]
-thingoof intersection_x_values ==
-[4*x - 2*y + 0 + 3]
-[y]
-ok so it is a bare function and not a system of equations
-[-x**2 + 10*x + y - 10]
-[y]
-ok so it is a bare function and not a system of equations
-functions_in_y_format == [[2*x + 3/2], [x**2 - 10*x + 10]]
-bigger function: 2*x + 3/2
-smaller_fun : x**2 - 10*x + 10
-intersection_x_values[0] == 6 - sqrt(110)/2
-intersection_x_values[1] == sqrt(110)/2 + 6
-[33mArea: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2[0m
-Command result: -(sqrt(110)/2 + 6)**3/3 - 17*sqrt(110)/2 - 6*(6 - sqrt(110)/2)**2 + (6 - sqrt(110)/2)**3/3 + 6*(sqrt(110)/2 + 6)**2
-Command string: quit
-fewfeewfewfewf
-[92mThank you for using geometrylib! See you again soon![0m
